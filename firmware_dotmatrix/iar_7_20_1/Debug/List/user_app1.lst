###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         03/Feb/2019  22:50:00
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
#    Command line =  
#        -f C:\Users\Caleb\AppData\Local\Temp\EW626D.tmp
#        (C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
#        -D MPGL2 -D MPG2 --preprocess=c
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List
#        -lC
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List
#        -o
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\application\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.2\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List\user_app1.lst
#    Object file  =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj\user_app1.o
#
###############################################################################

C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
      1          /**********************************************************************************************************************
      2          File: user_app1.c                                                                
      3          
      4          ----------------------------------------------------------------------------------------------------------------------
      5          To start a new task using this user_app1 as a template:
      6           1. Copy both user_app1.c and user_app1.h to the Application directory
      7           2. Rename the files yournewtaskname.c and yournewtaskname.h
      8           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
      9           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app1" with "yournewtaskname"
     10           5. Use ctrl-h to find and replace all instances of "UserApp1" with "YourNewTaskName"
     11           6. Use ctrl-h to find and replace all instances of "USER_APP1" with "YOUR_NEW_TASK_NAME"
     12           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     13           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     14           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     15          10. Delete this text (between the dashed lines) and update the Description below to describe your task
     16          ----------------------------------------------------------------------------------------------------------------------
     17          
     18          Description:
     19          This is a user_app1.c file template 
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          Public functions:
     25          
     26          
     27          Protected System functions:
     28          void UserApp1Initialize(void)
     29          Runs required initialzation for the task.  Should only be called once in main init section.
     30          
     31          void UserApp1RunActiveState(void)
     32          Runs current task state.  Should only be called once in main loop.
     33          
     34          
     35          **********************************************************************************************************************/
     36          
     37          #include "configuration.h"
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_UserApp1"
     42          ***********************************************************************************************************************/
     43          /* New variables */

   \                                 In section .bss, align 4
     44          volatile u32 G_u32UserApp1Flags;                       /* Global state flags */
   \                     G_u32UserApp1Flags:
   \        0x0                      DS8 4
     45          
     46          
     47          /*--------------------------------------------------------------------------------------------------------------------*/
     48          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     49          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     50          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     51          
     52          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     53          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     54          
     55          
     56          /***********************************************************************************************************************
     57          Global variable definitions with scope limited to this local application.
     58          Variable names shall start with "UserApp1_" and be declared as static.
     59          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     60          static fnCode_type UserApp1_StateMachine;            /* The state machine function pointer */
   \                     UserApp1_StateMachine:
   \        0x0                      DS8 4
     61          //static u32 UserApp1_u32Timeout;                      /* Timeout counter used across states */

   \                                 In section .bss, align 1
     62          static CapTouchMovementState horizontalMoveState;
   \                     horizontalMoveState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     63          static CapTouchMovementState verticalMoveState;
   \                     verticalMoveState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     64          static GameboardErrorType err;
   \                     err:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     65          static u32 u32Timer;
   \                     u32Timer:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     66          static CursorType cursor;
   \                     cursor:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
     67          static UserPlayState userPlayState;
   \                     userPlayState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     68          static Gameboard gameboard;
   \                     gameboard:
   \        0x0                      DS8 8
     69          
     70          /**********************************************************************************************************************
     71          Function Definitions
     72          **********************************************************************************************************************/
     73          
     74          /*--------------------------------------------------------------------------------------------------------------------*/
     75          /* Public functions                                                                                                   */
     76          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     77          GameboardErrorType setDot(GameboardCoordinateType* coordinate_)
     78          {
   \                     setDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     79            return drawDot(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     80          }
     81          

   \                                 In section .text, align 2, keep-with-next
     82          GameboardErrorType clearDot(GameboardCoordinateType* coordinate_)
     83          {
   \                     clearDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     84            return drawDot(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     85          }
     86          

   \                                 In section .text, align 2, keep-with-next
     87          GameboardErrorType setVerticalLine(GameboardCoordinateType* coordinate_)
     88          {
   \                     setVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     89            return drawVerticalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     90          }
     91          

   \                                 In section .text, align 2, keep-with-next
     92          GameboardErrorType clearVerticalLine(GameboardCoordinateType* coordinate_)
     93          {
   \                     clearVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     94            return drawVerticalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          GameboardErrorType setHorizontalLine(GameboardCoordinateType* coordinate_)
     98          {
   \                     setHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     99            return drawHorizontalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          GameboardErrorType clearHorizontalLine(GameboardCoordinateType* coordinate_)
    103          {
   \                     clearHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    104            return drawHorizontalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    105          }
    106          /*--------------------------------------------------------------------------------------------------------------------*/
    107          /* Protected functions                                                                                                */
    108          /*--------------------------------------------------------------------------------------------------------------------*/
    109          
    110          /*--------------------------------------------------------------------------------------------------------------------
    111          Function: UserApp1Initialize
    112          
    113          Description:
    114          Initializes the State Machine and its variables.
    115          
    116          Requires:
    117            -
    118          
    119          Promises:
    120            - 
    121          */

   \                                 In section .text, align 2, keep-with-next
    122          void UserApp1Initialize(void)
    123          {
   \                     UserApp1Initialize: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    124           
    125            /* If good initialization, set state to Idle */
    126            if( 1 )
    127            {
    128              UserApp1_StateMachine = UserApp1SM_Idle;
   \        0x2   0x....'....        ADR.W    R0,UserApp1SM_Idle
   \        0x6   0x....'....        LDR.W    R1,??DataTable8
   \        0xA   0x6008             STR      R0,[R1, #+0]
    129              
    130              /* Init Gameboard */
    131              LcdClearScreen();
   \        0xC   0x....'....        BL       LcdClearScreen
    132              drawEmptyGameboard();
   \       0x10   0x....'....        BL       drawEmptyGameboard
    133              
    134              /* Init captouch */
    135              CapTouchOn();
   \       0x14   0x....'....        BL       CapTouchOn
    136              
    137              /* Init cursor */
    138              cursor.cursorLocation.u8RowCoordinate = 0;
   \       0x18   0x....'....        LDR.W    R0,??DataTable8_1
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    139              cursor.cursorLocation.u8ColumnCoordinate = 0;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x7041             STRB     R1,[R0, #+1]
    140              cursor.cursorState = CURSOR_OFF;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x7081             STRB     R1,[R0, #+2]
    141              
    142              /* Init cursor state machine */
    143              horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x....'....        LDR.W    R1,??DataTable8_2
   \       0x2E   0x7008             STRB     R0,[R1, #+0]
    144              verticalMoveState = MOVEMENT_NOT_STARTED;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x....'....        LDR.W    R1,??DataTable8_3
   \       0x36   0x7008             STRB     R0,[R1, #+0]
    145              
    146              /* Init user play state machine. */
    147              userPlayState = SELECTED_NOTHING;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x....'....        LDR.W    R1,??DataTable8_4
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    148              
    149              /* Init gameboard */
    150              gameboard.pu8HorizontalLines = (u8*)malloc(sizeof(u8) * (GAMEBOARD_SIZE - 1));
   \       0x40   0x....'....        LDR.W    R4,??DataTable8_5
   \       0x44   0x2007             MOVS     R0,#+7
   \       0x46   0x....'....        BL       malloc
   \       0x4A   0x6020             STR      R0,[R4, #+0]
    151              gameboard.pu8VerticalLines = (u8*)malloc(sizeof(u8) * (GAMEBOARD_SIZE - 1));
   \       0x4C   0x2007             MOVS     R0,#+7
   \       0x4E   0x....'....        BL       malloc
   \       0x52   0x6060             STR      R0,[R4, #+4]
    152              for(uint8_t i = 0; i < GAMEBOARD_SIZE - 1; i++)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??UserApp1Initialize_0: (+1)
   \       0x56   0x0001             MOVS     R1,R0
   \       0x58   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x5A   0x2907             CMP      R1,#+7
   \       0x5C   0xDA0B             BGE.N    ??UserApp1Initialize_1
    153              {
    154                *(gameboard.pu8HorizontalLines + i) = 0;
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x6822             LDR      R2,[R4, #+0]
   \       0x62   0x0003             MOVS     R3,R0
   \       0x64   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x66   0x54D1             STRB     R1,[R2, R3]
    155                *(gameboard.pu8VerticalLines + i) = 0;
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x6862             LDR      R2,[R4, #+4]
   \       0x6C   0x0003             MOVS     R3,R0
   \       0x6E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x70   0x54D1             STRB     R1,[R2, R3]
    156              }
   \       0x72   0x1C40             ADDS     R0,R0,#+1
   \       0x74   0xE7EF             B.N      ??UserApp1Initialize_0
    157              
    158              /* Init app timer */
    159              u32Timer = 0;
   \                     ??UserApp1Initialize_1: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x....'....        LDR.W    R1,??DataTable8_6
   \       0x7C   0x6008             STR      R0,[R1, #+0]
    160              
    161              // Test Scoring
    162              SetNumberOfPlayers(3);
   \       0x7E   0x2003             MOVS     R0,#+3
   \       0x80   0x....'....        BL       SetNumberOfPlayers
    163              SetScore(2, 43);
   \       0x84   0x212B             MOVS     R1,#+43
   \       0x86   0x2002             MOVS     R0,#+2
   \       0x88   0x....'....        BL       SetScore
    164              SetScore(3, 1);
   \       0x8C   0x2101             MOVS     R1,#+1
   \       0x8E   0x2003             MOVS     R0,#+3
   \       0x90   0x....'....        BL       SetScore
    165              SetCurrentPlayer(3);
   \       0x94   0x2003             MOVS     R0,#+3
   \       0x96   0x....'....        BL       SetCurrentPlayer
    166              SetMessage(1);
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0x....'....        BL       SetMessage
    167            }
    168            else
    169            {
    170              /* The task isn't properly initialized, so shut it down and don't run */
    171              UserApp1_StateMachine = UserApp1SM_Error;
    172            }
    173          
    174          } /* end UserApp1Initialize() */
   \       0xA0   0xBD10             POP      {R4,PC}          ;; return
    175          
    176            
    177          /*----------------------------------------------------------------------------------------------------------------------
    178          Function UserApp1RunActiveState()
    179          
    180          Description:
    181          Selects and runs one iteration of the current state in the state machine.
    182          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    183          may take 1ms / n to execute.
    184          
    185          Requires:
    186            - State machine function pointer points at current state
    187          
    188          Promises:
    189            - Calls the function to pointed by the state machine function pointer
    190          */

   \                                 In section .text, align 2, keep-with-next
    191          void UserApp1RunActiveState(void)
    192          {
   \                     UserApp1RunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    193            UserApp1_StateMachine();
   \        0x2   0x....'....        LDR.W    R0,??DataTable8
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    194          
    195          } /* end UserApp1RunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    196          
    197          
    198          /*--------------------------------------------------------------------------------------------------------------------*/
    199          /* Private functions                                                                                                  */
    200          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    201          static GameboardErrorType drawDot(GameboardCoordinateType* coordinate_, DrawType drawType_)
    202          {
   \                     drawDot: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    203            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawDot_0
    204            {
    205              return BOUNDARY_ERROR_DOT_X;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE048             B.N      ??drawDot_1
    206            }
    207            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawDot_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawDot_2
    208            {
    209              return BOUNDARY_ERROR_DOT_Y;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE043             B.N      ??drawDot_1
    210            }
    211            
    212            u8 i, j;
    213            for(i = 0; i < GAMEBOARD_DOT_WIDTH; i++)
   \                     ??drawDot_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawDot_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xDA2A             BGE.N    ??drawDot_4
    214            {
    215              for(j = 0; j < GAMEBOARD_DOT_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawDot_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xDA22             BGE.N    ??drawDot_6
    216              {
    217                PixelAddressType pixel =
    218                {
    219                  .u16PixelRowAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET) + i,
    220                  .u16PixelColumnAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET) + j
    221                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1C89             ADDS     R1,R1,#+2
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1C89             ADDS     R1,R1,#+2
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    222                
    223                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawDot_7
    224                {
    225                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawDot_8
    226                }
    227                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawDot_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawDot_8
    228                {
    229                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    230                }
    231              }
   \                     ??drawDot_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawDot_5
    232            }
   \                     ??drawDot_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawDot_3
    233            
    234            PixelBlockType updateArea =
    235            {
    236              .u16RowStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET),
    237              .u16ColumnStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET),
    238              .u16RowSize = GAMEBOARD_DOT_WIDTH,
    239              .u16ColumnSize = GAMEBOARD_DOT_WIDTH
    240            };
   \                     ??drawDot_4: (+1)
   \       0x7A   0x....'....        LDR.W    R2,??DataTable8_7
   \       0x7E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x82   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0x00C0             LSLS     R0,R0,#+3
   \       0x8A   0x1C80             ADDS     R0,R0,#+2
   \       0x8C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x90   0x7860             LDRB     R0,[R4, #+1]
   \       0x92   0x00C0             LSLS     R0,R0,#+3
   \       0x94   0x1C80             ADDS     R0,R0,#+2
   \       0x96   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    241            
    242            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x....'....        BL       LcdUpdateScreenRefreshArea
    243            
    244            return GAMEBOARD_SUCCESS;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??drawDot_1: (+1)
   \       0xA2   0xBDFE             POP      {R1-R7,PC}       ;; return
    245          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000 0x0000      DC16 0, 0, 3, 3
   \               0x0003 0x000
   \              3            
    246          

   \                                 In section .text, align 2, keep-with-next
    247          static GameboardErrorType drawVerticalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    248          {
   \                     drawVerticalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    249            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawVerticalLine_0
    250            {
    251              return BOUNDARY_ERROR_VLINE_X;
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0xE048             B.N      ??drawVerticalLine_1
    252            }
    253            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE - 1)
   \                     ??drawVerticalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2807             CMP      R0,#+7
   \       0x14   0xDB01             BLT.N    ??drawVerticalLine_2
    254            {
    255              return BOUNDARY_ERROR_VLINE_Y;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xE043             B.N      ??drawVerticalLine_1
    256            }
    257            
    258            u8 i, j;
    259            for(i = 0; i < GAMEBOARD_LINE_LENGTH; i++)
   \                     ??drawVerticalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawVerticalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2805             CMP      R0,#+5
   \       0x22   0xDA2A             BGE.N    ??drawVerticalLine_4
    260            {
    261              for(j = 0; j < GAMEBOARD_LINE_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawVerticalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD122             BNE.N    ??drawVerticalLine_6
    262              {
    263                PixelAddressType pixel =
    264                {
    265                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    266                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    267                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1D49             ADDS     R1,R1,#+5
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1CC9             ADDS     R1,R1,#+3
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    268                
    269                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawVerticalLine_7
    270                {
    271                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawVerticalLine_8
    272                }
    273                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawVerticalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawVerticalLine_8
    274                {
    275                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    276                }
    277              }
   \                     ??drawVerticalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawVerticalLine_5
    278            }
   \                     ??drawVerticalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawVerticalLine_3
    279            
    280            PixelBlockType updateArea =
    281            {
    282              .u16RowStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    283              .u16ColumnStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    284              .u16RowSize = GAMEBOARD_LINE_LENGTH,
    285              .u16ColumnSize = GAMEBOARD_LINE_WIDTH
    286            };
   \                     ??drawVerticalLine_4: (+1)
   \       0x7A   0x....'....        LDR.W    R2,??DataTable8_8
   \       0x7E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x82   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0x00C0             LSLS     R0,R0,#+3
   \       0x8A   0x1D40             ADDS     R0,R0,#+5
   \       0x8C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x90   0x7860             LDRB     R0,[R4, #+1]
   \       0x92   0x00C0             LSLS     R0,R0,#+3
   \       0x94   0x1CC0             ADDS     R0,R0,#+3
   \       0x96   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    287            
    288            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x....'....        BL       LcdUpdateScreenRefreshArea
    289            
    290            return GAMEBOARD_SUCCESS;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??drawVerticalLine_1: (+1)
   \       0xA2   0xBDFE             POP      {R1-R7,PC}       ;; return
    291          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000 0x0000      DC16 0, 0, 5, 1
   \               0x0005 0x000
   \              1            
    292          

   \                                 In section .text, align 2, keep-with-next
    293          static GameboardErrorType drawHorizontalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    294          {
   \                     drawHorizontalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    295            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE - 1)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2807             CMP      R0,#+7
   \        0xA   0xDB01             BLT.N    ??drawHorizontalLine_0
    296            {
    297              return BOUNDARY_ERROR_HLINE_X;
   \        0xC   0x2005             MOVS     R0,#+5
   \        0xE   0xE047             B.N      ??drawHorizontalLine_1
    298            }
    299            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawHorizontalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawHorizontalLine_2
    300            {
    301              return BOUNDARY_ERROR_HLINE_Y;
   \       0x16   0x2006             MOVS     R0,#+6
   \       0x18   0xE042             B.N      ??drawHorizontalLine_1
    302            }
    303            
    304            u8 i, j;
    305            for(i = 0; i < GAMEBOARD_LINE_WIDTH; i++)
   \                     ??drawHorizontalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawHorizontalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD12A             BNE.N    ??drawHorizontalLine_4
    306            {
    307              for(j = 0; j < GAMEBOARD_LINE_LENGTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawHorizontalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2805             CMP      R0,#+5
   \       0x2E   0xDA22             BGE.N    ??drawHorizontalLine_6
    308              {
    309                PixelAddressType pixel =
    310                {
    311                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    312                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    313                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1CC9             ADDS     R1,R1,#+3
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1D49             ADDS     R1,R1,#+5
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    314                
    315                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawHorizontalLine_7
    316                {
    317                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawHorizontalLine_8
    318                }
    319                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawHorizontalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawHorizontalLine_8
    320                {
    321                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    322                }
    323              }
   \                     ??drawHorizontalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawHorizontalLine_5
    324            }
   \                     ??drawHorizontalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawHorizontalLine_3
    325            
    326            PixelBlockType updateArea =
    327            {
    328              .u16RowStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    329              .u16ColumnStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    330              .u16RowSize = GAMEBOARD_LINE_WIDTH,
    331              .u16ColumnSize = GAMEBOARD_LINE_LENGTH
    332            };
   \                     ??drawHorizontalLine_4: (+1)
   \       0x7A   0x....             LDR.N    R2,??DataTable8_9
   \       0x7C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x80   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x84   0x7820             LDRB     R0,[R4, #+0]
   \       0x86   0x00C0             LSLS     R0,R0,#+3
   \       0x88   0x1CC0             ADDS     R0,R0,#+3
   \       0x8A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x8E   0x7860             LDRB     R0,[R4, #+1]
   \       0x90   0x00C0             LSLS     R0,R0,#+3
   \       0x92   0x1D40             ADDS     R0,R0,#+5
   \       0x94   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    333            
    334            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x98   0xA801             ADD      R0,SP,#+4
   \       0x9A   0x....'....        BL       LcdUpdateScreenRefreshArea
    335            
    336            return GAMEBOARD_SUCCESS;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??drawHorizontalLine_1: (+1)
   \       0xA0   0xBDFE             POP      {R1-R7,PC}       ;; return
    337          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000 0x0000      DC16 0, 0, 1, 5
   \               0x0001 0x000
   \              5            
    338          

   \                                 In section .text, align 2, keep-with-next
    339          static GameboardErrorType drawEmptyGameboard(void)
    340          {
   \                     drawEmptyGameboard: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    341            u8 i, j;
    342            for(i = 0; i < GAMEBOARD_SIZE; i++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??drawEmptyGameboard_0: (+1)
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDA10             BGE.N    ??drawEmptyGameboard_1
    343            {
    344              for(j = 0; j < GAMEBOARD_SIZE; j++)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x0005             MOVS     R5,R0
   \                     ??drawEmptyGameboard_2: (+1)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x14   0x2808             CMP      R0,#+8
   \       0x16   0xDA08             BGE.N    ??drawEmptyGameboard_3
    345              {
    346                GameboardCoordinateType coordinate =
    347                {
    348                  .u8RowCoordinate = i,
    349                  .u8ColumnCoordinate = j
    350                };
   \       0x18   0xF88D 0x4000      STRB     R4,[SP, #+0]
   \       0x1C   0xF88D 0x5001      STRB     R5,[SP, #+1]
    351                setDot(&coordinate);
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x....'....        BL       setDot
    352              }
   \       0x26   0x1C6D             ADDS     R5,R5,#+1
   \       0x28   0xE7F2             B.N      ??drawEmptyGameboard_2
    353            }
   \                     ??drawEmptyGameboard_3: (+1)
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \       0x2C   0xE7EA             B.N      ??drawEmptyGameboard_0
    354            
    355            return GAMEBOARD_SUCCESS;
   \                     ??drawEmptyGameboard_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    356          }
    357          
    358          static GameboardErrorType testGameboardDrawingFunctions(void)
                                           ^
Warning[Pe177]: function "testGameboardDrawingFunctions" was declared but never
          referenced
    359          {
    360              static u8 i = 0;
    361              static u8 j = 0;
    362              static DrawingTestState state = SETTING_DOTS;
    363              GameboardErrorType err;
    364              GameboardCoordinateType coord;
    365              
    366              switch(state)
    367              {
    368                case SETTING_DOTS:
    369                  coord.u8RowCoordinate = i;
    370                  coord.u8ColumnCoordinate = j;
    371                  err = setDot(&coord);
    372                  if(err != GAMEBOARD_SUCCESS)
    373                  {
    374                    return err;
    375                  }
    376                  if(j < 7)
    377                  {
    378                    j++;
    379                  }
    380                  else if(i < 7)
    381                  {
    382                    i++;
    383                    j = 0;
    384                  }
    385                  else
    386                  {
    387                    i = 0;
    388                    j = 0;
    389                    state = SETTING_VLINES;
    390                  }
    391                  break;
    392                  
    393                case SETTING_VLINES:
    394                  coord.u8RowCoordinate = i;
    395                  coord.u8ColumnCoordinate = j;
    396                  err = setVerticalLine(&coord);
    397                  if(err != GAMEBOARD_SUCCESS)
    398                  {
    399                    return err;
    400                  }
    401                  if(j < 7)
    402                  {
    403                    j++;
    404                  }
    405                  else if(i < 6)
    406                  {
    407                    i++;
    408                    j = 0;
    409                  }
    410                  else
    411                  {
    412                    i = 0; 
    413                    j = 0; 
    414                    state = SETTING_HLINES;
    415                  }
    416                  break;
    417                  
    418                case SETTING_HLINES:
    419                  coord.u8RowCoordinate = i;
    420                  coord.u8ColumnCoordinate = j;
    421                  err = setHorizontalLine(&coord);
    422                  if(err != GAMEBOARD_SUCCESS)
    423                  {
    424                    return err;
    425                  }
    426                  if(j < 6)
    427                  {
    428                    j++;
    429                  }
    430                  else if( i < 7)
    431                  {
    432                    i++;
    433                    j = 0;
    434                  }
    435                  else
    436                  {
    437                    state = CLEARING_HLINES;
    438                  }
    439                  break;
    440                  
    441              case CLEARING_HLINES:
    442                coord.u8RowCoordinate = i;
    443                coord.u8ColumnCoordinate = j;
    444                err = clearHorizontalLine(&coord);
    445                if(err != GAMEBOARD_SUCCESS)
    446                {
    447                  return err;
    448                }
    449                if(j != 0)
    450                {
    451                  j--;
    452                }
    453                else if(i != 0)
    454                {
    455                  i--;
    456                  j = 6;
    457                }
    458                else
    459                {
    460                  i = 6;
    461                  j = 7;
    462                  state = CLEARING_VLINES;
    463                }
    464                break;
    465                
    466              case CLEARING_VLINES:
    467                coord.u8RowCoordinate = i;
    468                coord.u8ColumnCoordinate = j;
    469                err = clearVerticalLine(&coord);
    470                if(err != GAMEBOARD_SUCCESS)
    471                {
    472                  return err;
    473                }
    474                if(j != 0)
    475                {
    476                  j--;
    477                }
    478                else if(i != 0)
    479                {
    480                  i--;
    481                  j = 7;
    482                }
    483                else
    484                {
    485                  i = 7;
    486                  j = 7;
    487                  state = CLEARING_DOTS;
    488                }
    489                break;
    490                
    491              case CLEARING_DOTS:
    492                coord.u8RowCoordinate = i;
    493                coord.u8ColumnCoordinate = j;
    494                err = clearDot(&coord);
    495                if(err != GAMEBOARD_SUCCESS)
    496                {
    497                  return err;
    498                }
    499                if(j != 0)
    500                {
    501                  j--;
    502                }
    503                else if(i != 0)
    504                {
    505                  i--;
    506                  j = 7;
    507                }
    508                else
    509                {
    510                  state = DRAWING_COMPLETE;
    511                }
    512              }
    513          
    514              return GAMEBOARD_SUCCESS;
    515          }
    516          

   \                                 In section .text, align 2, keep-with-next
    517          static GameboardErrorType blinkCursor(void)
    518          {
   \                     blinkCursor: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    519            if(u32Timer % 250 == 0)
   \        0x2   0x20FA             MOVS     R0,#+250
   \        0x4   0x....             LDR.N    R1,??DataTable8_6
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \        0xE   0xFB00 0x2011      MLS      R0,R0,R1,R2
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD11F             BNE.N    ??blinkCursor_0
    520            {
    521              switch(cursor.cursorState)
   \       0x16   0x....             LDR.N    R4,??DataTable8_1
   \       0x18   0x78A0             LDRB     R0,[R4, #+2]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??blinkCursor_1
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD00D             BEQ.N    ??blinkCursor_2
   \       0x22   0xE018             B.N      ??blinkCursor_0
    522              {
    523                case CURSOR_OFF:
    524                  err = setDot(&cursor.cursorLocation);
   \                     ??blinkCursor_1: (+1)
   \       0x24   0x....             LDR.N    R5,??DataTable8_10
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x....'....        BL       setDot
   \       0x2C   0x7028             STRB     R0,[R5, #+0]
    525                  if(err != GAMEBOARD_SUCCESS)
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD001             BEQ.N    ??blinkCursor_3
    526                  {
    527                    return err;
   \       0x34   0x7828             LDRB     R0,[R5, #+0]
   \       0x36   0xE00F             B.N      ??blinkCursor_4
    528                  }
    529                  cursor.cursorState = CURSOR_ON;
   \                     ??blinkCursor_3: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0x70A0             STRB     R0,[R4, #+2]
    530                  break;
   \       0x3C   0xE00B             B.N      ??blinkCursor_0
    531                  
    532                case CURSOR_ON:
    533                  err = clearDot(&cursor.cursorLocation);
   \                     ??blinkCursor_2: (+1)
   \       0x3E   0x....             LDR.N    R5,??DataTable8_10
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       clearDot
   \       0x46   0x7028             STRB     R0,[R5, #+0]
    534                  if(err != GAMEBOARD_SUCCESS)
   \       0x48   0x7828             LDRB     R0,[R5, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??blinkCursor_5
    535                  {
    536                    return err;
   \       0x4E   0x7828             LDRB     R0,[R5, #+0]
   \       0x50   0xE002             B.N      ??blinkCursor_4
    537                  }
    538                  cursor.cursorState = CURSOR_OFF;
   \                     ??blinkCursor_5: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x70A0             STRB     R0,[R4, #+2]
    539                  break;
    540              }
    541            }
    542            
    543            return GAMEBOARD_SUCCESS;
   \                     ??blinkCursor_0: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??blinkCursor_4: (+1)
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    544          }
    545          

   \                                 In section .text, align 2, keep-with-next
    546          static GameboardErrorType moveCursor(void)
    547          {
   \                     moveCursor: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    548            u8 horizontalSliderPos = CaptouchCurrentHSlidePosition();
   \        0x4   0x....'....        BL       CaptouchCurrentHSlidePosition
   \        0x8   0x0004             MOVS     R4,R0
    549            u8 verticalSliderPos = CaptouchCurrentVSlidePosition();
   \        0xA   0x....'....        BL       CaptouchCurrentVSlidePosition
   \        0xE   0x0005             MOVS     R5,R0
    550            
    551            switch(horizontalMoveState)
   \       0x10   0x....             LDR.N    R6,??DataTable8_2
   \       0x12   0x7830             LDRB     R0,[R6, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??moveCursor_0
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD00B             BEQ.N    ??moveCursor_1
   \       0x1C   0xE04B             B.N      ??moveCursor_2
    552            {
    553              case MOVEMENT_NOT_STARTED:
    554                if(horizontalSliderPos >= CAPTOUCH_HORIZONTAL_LEFT_THRESHOLD &&
    555                   horizontalSliderPos < CAPTOUCH_HORIZONTAL_RIGHT_THRESHOLD)
   \                     ??moveCursor_0: (+1)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x22   0x2840             CMP      R0,#+64
   \       0x24   0xDB05             BLT.N    ??moveCursor_3
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2A   0x28C0             CMP      R0,#+192
   \       0x2C   0xDA01             BGE.N    ??moveCursor_3
    556                {
    557                  horizontalMoveState = MOVEMENT_STARTED;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x7030             STRB     R0,[R6, #+0]
    558                }
    559                break;
   \                     ??moveCursor_3: (+1)
   \       0x32   0xE040             B.N      ??moveCursor_2
    560              case MOVEMENT_STARTED:
    561                if(horizontalSliderPos < CAPTOUCH_HORIZONTAL_LEFT_THRESHOLD)
   \                     ??moveCursor_1: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0x2840             CMP      R0,#+64
   \       0x3A   0xDA1C             BGE.N    ??moveCursor_4
    562                {
    563                  /* Check if the cursor is already at the left border of the screen. */
    564                  if(cursor.cursorLocation.u8ColumnCoordinate == 0)
   \       0x3C   0x....             LDR.N    R7,??DataTable8_1
   \       0x3E   0x7878             LDRB     R0,[R7, #+1]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD038             BEQ.N    ??moveCursor_2
    565                  {
    566                    break;
    567                  }
    568                  /* If the cursor is currently off, turn it on before moving it. */
    569                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_5: (+1)
   \       0x44   0x78B8             LDRB     R0,[R7, #+2]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD10F             BNE.N    ??moveCursor_6
    570                  {
    571                    err = setDot(&cursor.cursorLocation);
   \       0x4A   0x....'....        LDR.W    R8,??DataTable8_10
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0x....'....        BL       setDot
   \       0x54   0xF888 0x0000      STRB     R0,[R8, #+0]
    572                    if(err != GAMEBOARD_SUCCESS)
   \       0x58   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD002             BEQ.N    ??moveCursor_7
    573                    {
    574                      return err;
   \       0x60   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x64   0xE07B             B.N      ??moveCursor_8
    575                    }
    576                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_7: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0x70B8             STRB     R0,[R7, #+2]
    577                  }
    578                  
    579                  /* Update the cursor location and move the cursor state machine. */
    580                  cursor.cursorLocation.u8ColumnCoordinate--;
   \                     ??moveCursor_6: (+1)
   \       0x6A   0x7878             LDRB     R0,[R7, #+1]
   \       0x6C   0x1E40             SUBS     R0,R0,#+1
   \       0x6E   0x7078             STRB     R0,[R7, #+1]
    581                  horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7030             STRB     R0,[R6, #+0]
   \       0x74   0xE01F             B.N      ??moveCursor_9
    582                }
    583                else if(horizontalSliderPos >= CAPTOUCH_HORIZONTAL_RIGHT_THRESHOLD)
   \                     ??moveCursor_4: (+1)
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x7A   0x28C0             CMP      R0,#+192
   \       0x7C   0xDB1B             BLT.N    ??moveCursor_9
    584                {
    585                  /* Check if the cursor is already at the right border of the screen. */
    586                  if(cursor.cursorLocation.u8ColumnCoordinate == GAMEBOARD_SIZE - 1)
   \       0x7E   0x....             LDR.N    R7,??DataTable8_1
   \       0x80   0x7878             LDRB     R0,[R7, #+1]
   \       0x82   0x2807             CMP      R0,#+7
   \       0x84   0xD017             BEQ.N    ??moveCursor_2
    587                  {
    588                    break;
    589                  }
    590                  
    591                  /* If the cursor is currently off, turn it on before moving it. */
    592                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_10: (+1)
   \       0x86   0x78B8             LDRB     R0,[R7, #+2]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD10F             BNE.N    ??moveCursor_11
    593                  {
    594                    err = setDot(&cursor.cursorLocation);
   \       0x8C   0x....'....        LDR.W    R8,??DataTable8_10
   \       0x90   0x0038             MOVS     R0,R7
   \       0x92   0x....'....        BL       setDot
   \       0x96   0xF888 0x0000      STRB     R0,[R8, #+0]
    595                    if(err != GAMEBOARD_SUCCESS)
   \       0x9A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD002             BEQ.N    ??moveCursor_12
    596                    {
    597                      return err;
   \       0xA2   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xA6   0xE05A             B.N      ??moveCursor_8
    598                    }
    599                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_12: (+1)
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x70B8             STRB     R0,[R7, #+2]
    600                  }
    601                  
    602                  /* Update the cursor location and move the state machine. */
    603                  cursor.cursorLocation.u8ColumnCoordinate++;
   \                     ??moveCursor_11: (+1)
   \       0xAC   0x7878             LDRB     R0,[R7, #+1]
   \       0xAE   0x1C40             ADDS     R0,R0,#+1
   \       0xB0   0x7078             STRB     R0,[R7, #+1]
    604                  horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x7030             STRB     R0,[R6, #+0]
    605                }
    606                break;
    607            }
    608            
    609            switch(verticalMoveState)
   \                     ??moveCursor_9: (+1)
   \                     ??moveCursor_2: (+1)
   \       0xB6   0x....             LDR.N    R6,??DataTable8_3
   \       0xB8   0x7830             LDRB     R0,[R6, #+0]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD002             BEQ.N    ??moveCursor_13
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD00B             BEQ.N    ??moveCursor_14
   \       0xC2   0xE04B             B.N      ??moveCursor_15
    610            {
    611              case MOVEMENT_NOT_STARTED:
    612                if(verticalSliderPos >= CAPTOUCH_VERTICAL_DOWN_THRESHOLD &&
    613                   verticalSliderPos < CAPTOUCH_VERTICAL_UP_THRESHOLD)
   \                     ??moveCursor_13: (+1)
   \       0xC4   0x0028             MOVS     R0,R5
   \       0xC6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xC8   0x2840             CMP      R0,#+64
   \       0xCA   0xDB05             BLT.N    ??moveCursor_16
   \       0xCC   0x0028             MOVS     R0,R5
   \       0xCE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xD0   0x28C0             CMP      R0,#+192
   \       0xD2   0xDA01             BGE.N    ??moveCursor_16
    614                {
    615                  verticalMoveState = MOVEMENT_STARTED;
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0x7030             STRB     R0,[R6, #+0]
    616                }
    617                break;
   \                     ??moveCursor_16: (+1)
   \       0xD8   0xE040             B.N      ??moveCursor_15
    618              case MOVEMENT_STARTED:
    619                if(verticalSliderPos < CAPTOUCH_VERTICAL_DOWN_THRESHOLD)
   \                     ??moveCursor_14: (+1)
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xDE   0x2840             CMP      R0,#+64
   \       0xE0   0xDA1C             BGE.N    ??moveCursor_17
    620                {
    621                  /* Check if the cursor is already at the bottom border of the screen. */
    622                  if(cursor.cursorLocation.u8RowCoordinate == 0)
   \       0xE2   0x....             LDR.N    R7,??DataTable8_1
   \       0xE4   0x7838             LDRB     R0,[R7, #+0]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD038             BEQ.N    ??moveCursor_15
    623                  {
    624                    break;
    625                  }
    626                  /* If the cursor is currently off, turn it on before moving it. */
    627                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_18: (+1)
   \       0xEA   0x78B8             LDRB     R0,[R7, #+2]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD10F             BNE.N    ??moveCursor_19
    628                  {
    629                    err = setDot(&cursor.cursorLocation);
   \       0xF0   0x....'....        LDR.W    R8,??DataTable8_10
   \       0xF4   0x0038             MOVS     R0,R7
   \       0xF6   0x....'....        BL       setDot
   \       0xFA   0xF888 0x0000      STRB     R0,[R8, #+0]
    630                    if(err != GAMEBOARD_SUCCESS)
   \       0xFE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD002             BEQ.N    ??moveCursor_20
    631                    {
    632                      return err;
   \      0x106   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x10A   0xE028             B.N      ??moveCursor_8
    633                    }
    634                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_20: (+1)
   \      0x10C   0x2001             MOVS     R0,#+1
   \      0x10E   0x70B8             STRB     R0,[R7, #+2]
    635                  }
    636                  
    637                  /* Update the cursor location and move the cursor state machine. */
    638                  cursor.cursorLocation.u8RowCoordinate--;
   \                     ??moveCursor_19: (+1)
   \      0x110   0x7838             LDRB     R0,[R7, #+0]
   \      0x112   0x1E40             SUBS     R0,R0,#+1
   \      0x114   0x7038             STRB     R0,[R7, #+0]
    639                  verticalMoveState = MOVEMENT_NOT_STARTED;
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x7030             STRB     R0,[R6, #+0]
   \      0x11A   0xE01F             B.N      ??moveCursor_21
    640                }
    641                else if(verticalSliderPos >= CAPTOUCH_VERTICAL_UP_THRESHOLD)
   \                     ??moveCursor_17: (+1)
   \      0x11C   0x0028             MOVS     R0,R5
   \      0x11E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x120   0x28C0             CMP      R0,#+192
   \      0x122   0xDB1B             BLT.N    ??moveCursor_21
    642                {
    643                  /* Check if the cursor is already at the upper border of the screen. */
    644                  if(cursor.cursorLocation.u8RowCoordinate == GAMEBOARD_SIZE - 1)
   \      0x124   0x....             LDR.N    R7,??DataTable8_1
   \      0x126   0x7838             LDRB     R0,[R7, #+0]
   \      0x128   0x2807             CMP      R0,#+7
   \      0x12A   0xD017             BEQ.N    ??moveCursor_15
    645                  {
    646                    break;
    647                  }
    648                  
    649                  /* If the cursor is currently off, turn it on before moving it. */
    650                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_22: (+1)
   \      0x12C   0x78B8             LDRB     R0,[R7, #+2]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD10F             BNE.N    ??moveCursor_23
    651                  {
    652                    err = setDot(&cursor.cursorLocation);
   \      0x132   0x....'....        LDR.W    R8,??DataTable8_10
   \      0x136   0x0038             MOVS     R0,R7
   \      0x138   0x....'....        BL       setDot
   \      0x13C   0xF888 0x0000      STRB     R0,[R8, #+0]
    653                    if(err != GAMEBOARD_SUCCESS)
   \      0x140   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x144   0x2800             CMP      R0,#+0
   \      0x146   0xD002             BEQ.N    ??moveCursor_24
    654                    {
    655                      return err;
   \      0x148   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x14C   0xE007             B.N      ??moveCursor_8
    656                    }
    657                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_24: (+1)
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0x70B8             STRB     R0,[R7, #+2]
    658                  }
    659                  
    660                  /* Update the cursor location and move the state machine. */
    661                  cursor.cursorLocation.u8RowCoordinate++;
   \                     ??moveCursor_23: (+1)
   \      0x152   0x7838             LDRB     R0,[R7, #+0]
   \      0x154   0x1C40             ADDS     R0,R0,#+1
   \      0x156   0x7038             STRB     R0,[R7, #+0]
    662                  verticalMoveState = MOVEMENT_NOT_STARTED;
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0x7030             STRB     R0,[R6, #+0]
    663                }
    664                break;
    665            }
    666            
    667            return GAMEBOARD_SUCCESS;
   \                     ??moveCursor_21: (+1)
   \                     ??moveCursor_15: (+1)
   \      0x15C   0x2000             MOVS     R0,#+0
   \                     ??moveCursor_8: (+1)
   \      0x15E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    668          }
    669          /**********************************************************************************************************************
    670          State Machine Function Definitions
    671          **********************************************************************************************************************/
    672          
    673          /*-------------------------------------------------------------------------------------------------------------------*/
    674          /* Wait for ??? */

   \                                 In section .text, align 4, keep-with-next
    675          static void UserApp1SM_Idle(void)
    676          {
   \                     UserApp1SM_Idle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    677            switch(userPlayState)
   \        0x2   0x....             LDR.N    R0,??DataTable8_4
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD003             BEQ.N    ??UserApp1SM_Idle_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD00A             BEQ.N    ??UserApp1SM_Idle_1
   \        0xE   0xD308             BCC.N    ??UserApp1SM_Idle_2
   \       0x10   0xE008             B.N      ??UserApp1SM_Idle_3
    678            {
    679              /* Here the user has not selected any dots to start their turn. Functionality should allow the user to move around
    680               * the gameboard by blinking the cursor, and moving the cursor based on input from the captouch sensors. The next
    681               * state (SELECTED_FIRST_DOT) is achieved after the user has selected a dot with BUTTON1 */
    682              case SELECTED_NOTHING:
    683                err = blinkCursor();
   \                     ??UserApp1SM_Idle_0: (+1)
   \       0x12   0x....             LDR.N    R4,??DataTable8_10
   \       0x14   0x....'....        BL       blinkCursor
   \       0x18   0x7020             STRB     R0,[R4, #+0]
    684                if(err != GAMEBOARD_SUCCESS)
    685                {
    686                  //????
    687                }
    688                err = moveCursor();
   \       0x1A   0x....'....        BL       moveCursor
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
    689                if(err != GAMEBOARD_SUCCESS)
    690                {
    691                  //????
    692                }
    693                break;
   \       0x20   0xE000             B.N      ??UserApp1SM_Idle_3
    694              
    695              /* Here the user has selected one dot and must now select a second. Functionality should allow the user to select
    696               * between possible second dots by blinking a possible line that would connect two dots and switch between possible
    697               * line options by taking input from the captouch sensors. From here, the user can go back to the previous state
    698               * (SELECT_NOTHING) by pressing BUTTON0 or go forward to the next state (SELECTED_SECOND_DOT) by pressing BUTTON1
    699               * when they've reached their desired second dot option. */
    700              case SELECTED_FIRST_DOT:
    701                break;
   \                     ??UserApp1SM_Idle_2: (+1)
   \       0x22   0xE7FF             B.N      ??UserApp1SM_Idle_3
    702              
    703               /* Here the user has selected both dots and their turn is over. No more functionality must be provided to the user
    704                * until the user play state machine is started again. The players move on the gameboard should be updated in the
    705                * global gameboard variable */
    706              case SELECTED_SECOND_DOT:
    707                break;
    708            }
    709            
    710            /* Don't ever remove this! Other functions are depending on it!! */
    711            u32Timer++;
   \                     ??UserApp1SM_Idle_1: (+1)
   \                     ??UserApp1SM_Idle_3: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable8_6
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x6001             STR      R1,[R0, #+0]
    712            
    713          } /* end UserApp1SM_Idle() */
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     UserApp1_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     cursor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     horizontalMoveState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     verticalMoveState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     userPlayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     gameboard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     err
    714              
    715          
    716          /*-------------------------------------------------------------------------------------------------------------------*/
    717          /* Handle an error */
    718          static void UserApp1SM_Error(void)          
    719          {
    720            
    721          } /* end UserApp1SM_Error() */
    722          
    723          
    724          
    725          /*--------------------------------------------------------------------------------------------------------------------*/
    726          /* End of File                                                                                                        */
    727          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserApp1Initialize
         8   -> CapTouchOn
         8   -> LcdClearScreen
         8   -> SetCurrentPlayer
         8   -> SetMessage
         8   -> SetNumberOfPlayers
         8   -> SetScore
         8   -> drawEmptyGameboard
         8   -> malloc
       8   UserApp1RunActiveState
         8   -- Indirect call
       8   UserApp1SM_Idle
         8   -> blinkCursor
         8   -> moveCursor
      16   blinkCursor
        16   -> clearDot
        16   -> setDot
       8   clearDot
         8   -> drawDot
       8   clearHorizontalLine
         8   -> drawHorizontalLine
       8   clearVerticalLine
         8   -> drawVerticalLine
      32   drawDot
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      16   drawEmptyGameboard
        16   -> setDot
      32   drawHorizontalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      32   drawVerticalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      24   moveCursor
        24   -> CaptouchCurrentHSlidePosition
        24   -> CaptouchCurrentVSlidePosition
        24   -> setDot
       8   setDot
         8   -> drawDot
       8   setHorizontalLine
         8   -> drawHorizontalLine
       8   setVerticalLine
         8   -> drawVerticalLine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?_0
       8  ?_1
       8  ?_2
       4  G_u32UserApp1Flags
     162  UserApp1Initialize
      12  UserApp1RunActiveState
      46  UserApp1SM_Idle
       4  UserApp1_StateMachine
      90  blinkCursor
      14  clearDot
      14  clearHorizontalLine
      14  clearVerticalLine
       4  cursor
     164  drawDot
      50  drawEmptyGameboard
     162  drawHorizontalLine
     164  drawVerticalLine
       1  err
       8  gameboard
       1  horizontalMoveState
     354  moveCursor
      14  setDot
      14  setHorizontalLine
      14  setVerticalLine
       4  u32Timer
       1  userPlayState
       1  verticalMoveState

 
    28 bytes in section .bss
    24 bytes in section .rodata
 1 332 bytes in section .text
 
 1 332 bytes of CODE  memory
    24 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: 1
