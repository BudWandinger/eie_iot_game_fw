###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         30/Jan/2019  05:26:22
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
#    Command line =  
#        -f C:\Users\Caleb\AppData\Local\Temp\EW4E81.tmp
#        (C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
#        -D MPGL2 -D MPG2 --preprocess=c
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List
#        -lC
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List
#        -o
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\bsp\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\drivers\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\application\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.2\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List\user_app1.lst
#    Object file  =  
#        C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj\user_app1.o
#
###############################################################################

C:\Users\Caleb\Documents\firmware\eie_iot_game_fw\firmware_common\application\user_app1.c
      1          /**********************************************************************************************************************
      2          File: user_app1.c                                                                
      3          
      4          ----------------------------------------------------------------------------------------------------------------------
      5          To start a new task using this user_app1 as a template:
      6           1. Copy both user_app1.c and user_app1.h to the Application directory
      7           2. Rename the files yournewtaskname.c and yournewtaskname.h
      8           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
      9           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app1" with "yournewtaskname"
     10           5. Use ctrl-h to find and replace all instances of "UserApp1" with "YourNewTaskName"
     11           6. Use ctrl-h to find and replace all instances of "USER_APP1" with "YOUR_NEW_TASK_NAME"
     12           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     13           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     14           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     15          10. Delete this text (between the dashed lines) and update the Description below to describe your task
     16          ----------------------------------------------------------------------------------------------------------------------
     17          
     18          Description:
     19          This is a user_app1.c file template 
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          Public functions:
     25          
     26          
     27          Protected System functions:
     28          void UserApp1Initialize(void)
     29          Runs required initialzation for the task.  Should only be called once in main init section.
     30          
     31          void UserApp1RunActiveState(void)
     32          Runs current task state.  Should only be called once in main loop.
     33          
     34          
     35          **********************************************************************************************************************/
     36          
     37          #include "configuration.h"
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_UserApp1"
     42          ***********************************************************************************************************************/
     43          /* New variables */

   \                                 In section .bss, align 4
     44          volatile u32 G_u32UserApp1Flags;                       /* Global state flags */
   \                     G_u32UserApp1Flags:
   \        0x0                      DS8 4
     45          
     46          
     47          /*--------------------------------------------------------------------------------------------------------------------*/
     48          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     49          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     50          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     51          
     52          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     53          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     54          
     55          
     56          /***********************************************************************************************************************
     57          Global variable definitions with scope limited to this local application.
     58          Variable names shall start with "UserApp1_" and be declared as static.
     59          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     60          static fnCode_type UserApp1_StateMachine;            /* The state machine function pointer */
   \                     UserApp1_StateMachine:
   \        0x0                      DS8 4
     61          //static u32 UserApp1_u32Timeout;                      /* Timeout counter used across states */

   \                                 In section .bss, align 1
     62          static CapTouchMovementState horizontalMoveState;
   \                     horizontalMoveState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     63          static CapTouchMovementState verticalMoveState;
   \                     verticalMoveState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     64          static GameboardErrorType err;
   \                     err:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     65          static u32 u32Timer;
   \                     u32Timer:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     66          static CursorType cursor;
   \                     cursor:
   \        0x0                      DS8 4

   \                                 In section .bss, align 1
     67          static UserPlayState userPlayState;
   \                     userPlayState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     68          static Gameboard gameboard;
   \                     gameboard:
   \        0x0                      DS8 8
     69          
     70          /**********************************************************************************************************************
     71          Function Definitions
     72          **********************************************************************************************************************/
     73          
     74          /*--------------------------------------------------------------------------------------------------------------------*/
     75          /* Public functions                                                                                                   */
     76          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     77          GameboardErrorType setDot(GameboardCoordinateType* coordinate_)
     78          {
   \                     setDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     79            return drawDot(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     80          }
     81          

   \                                 In section .text, align 2, keep-with-next
     82          GameboardErrorType clearDot(GameboardCoordinateType* coordinate_)
     83          {
   \                     clearDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     84            return drawDot(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     85          }
     86          

   \                                 In section .text, align 2, keep-with-next
     87          GameboardErrorType setVerticalLine(GameboardCoordinateType* coordinate_)
     88          {
   \                     setVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     89            return drawVerticalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     90          }
     91          

   \                                 In section .text, align 2, keep-with-next
     92          GameboardErrorType clearVerticalLine(GameboardCoordinateType* coordinate_)
     93          {
   \                     clearVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     94            return drawVerticalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     95          }
     96          

   \                                 In section .text, align 2, keep-with-next
     97          GameboardErrorType setHorizontalLine(GameboardCoordinateType* coordinate_)
     98          {
   \                     setHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     99            return drawHorizontalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    100          }
    101          

   \                                 In section .text, align 2, keep-with-next
    102          GameboardErrorType clearHorizontalLine(GameboardCoordinateType* coordinate_)
    103          {
   \                     clearHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    104            return drawHorizontalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    105          }
    106          /*--------------------------------------------------------------------------------------------------------------------*/
    107          /* Protected functions                                                                                                */
    108          /*--------------------------------------------------------------------------------------------------------------------*/
    109          
    110          /*--------------------------------------------------------------------------------------------------------------------
    111          Function: UserApp1Initialize
    112          
    113          Description:
    114          Initializes the State Machine and its variables.
    115          
    116          Requires:
    117            -
    118          
    119          Promises:
    120            - 
    121          */

   \                                 In section .text, align 2, keep-with-next
    122          void UserApp1Initialize(void)
    123          {
   \                     UserApp1Initialize: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    124           
    125            /* If good initialization, set state to Idle */
    126            if( 1 )
    127            {
    128              UserApp1_StateMachine = UserApp1SM_Idle;
   \        0x2   0x....'....        ADR.W    R0,UserApp1SM_Idle
   \        0x6   0x....'....        LDR.W    R1,??DataTable8
   \        0xA   0x6008             STR      R0,[R1, #+0]
    129              
    130              /* Init Gameboard */
    131              LcdClearScreen();
   \        0xC   0x....'....        BL       LcdClearScreen
    132              drawEmptyGameboard();
   \       0x10   0x....'....        BL       drawEmptyGameboard
    133              
    134              /* Init captouch */
    135              CapTouchOn();
   \       0x14   0x....'....        BL       CapTouchOn
    136              
    137              /* Init cursor */
    138              cursor.cursorLocation.u8RowCoordinate = 0;
   \       0x18   0x....'....        LDR.W    R0,??DataTable8_1
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x7001             STRB     R1,[R0, #+0]
    139              cursor.cursorLocation.u8ColumnCoordinate = 0;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x7041             STRB     R1,[R0, #+1]
    140              cursor.cursorState = CURSOR_OFF;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x7081             STRB     R1,[R0, #+2]
    141              
    142              /* Init cursor state machine */
    143              horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x....'....        LDR.W    R1,??DataTable8_2
   \       0x2E   0x7008             STRB     R0,[R1, #+0]
    144              verticalMoveState = MOVEMENT_NOT_STARTED;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x....'....        LDR.W    R1,??DataTable8_3
   \       0x36   0x7008             STRB     R0,[R1, #+0]
    145              
    146              /* Init user play state machine. */
    147              userPlayState = SELECTED_NOTHING;
   \       0x38   0x2000             MOVS     R0,#+0
   \       0x3A   0x....'....        LDR.W    R1,??DataTable8_4
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
    148              
    149              /* Init gameboard */
    150              gameboard.pu8HorizontalLines = (u8*)malloc(sizeof(u8) * (GAMEBOARD_SIZE - 1));
   \       0x40   0x....'....        LDR.W    R4,??DataTable8_5
   \       0x44   0x2007             MOVS     R0,#+7
   \       0x46   0x....'....        BL       malloc
   \       0x4A   0x6020             STR      R0,[R4, #+0]
    151              gameboard.pu8VerticalLines = (u8*)malloc(sizeof(u8) * (GAMEBOARD_SIZE - 1));
   \       0x4C   0x2007             MOVS     R0,#+7
   \       0x4E   0x....'....        BL       malloc
   \       0x52   0x6060             STR      R0,[R4, #+4]
    152              for(uint8_t i = 0; i < GAMEBOARD_SIZE - 1; i++)
   \       0x54   0x2000             MOVS     R0,#+0
   \                     ??UserApp1Initialize_0: (+1)
   \       0x56   0x0001             MOVS     R1,R0
   \       0x58   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x5A   0x2907             CMP      R1,#+7
   \       0x5C   0xDA0B             BGE.N    ??UserApp1Initialize_1
    153              {
    154                *(gameboard.pu8HorizontalLines + i) = 0;
   \       0x5E   0x2100             MOVS     R1,#+0
   \       0x60   0x6822             LDR      R2,[R4, #+0]
   \       0x62   0x0003             MOVS     R3,R0
   \       0x64   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x66   0x54D1             STRB     R1,[R2, R3]
    155                *(gameboard.pu8VerticalLines + i) = 0;
   \       0x68   0x2100             MOVS     R1,#+0
   \       0x6A   0x6862             LDR      R2,[R4, #+4]
   \       0x6C   0x0003             MOVS     R3,R0
   \       0x6E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \       0x70   0x54D1             STRB     R1,[R2, R3]
    156              }
   \       0x72   0x1C40             ADDS     R0,R0,#+1
   \       0x74   0xE7EF             B.N      ??UserApp1Initialize_0
    157              
    158              /* Init app timer */
    159              u32Timer = 0;
   \                     ??UserApp1Initialize_1: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x....'....        LDR.W    R1,??DataTable8_6
   \       0x7C   0x6008             STR      R0,[R1, #+0]
    160              
    161              // Test Scoring
    162              SetNumberOfPlayers(3);
   \       0x7E   0x2003             MOVS     R0,#+3
   \       0x80   0x....'....        BL       SetNumberOfPlayers
    163              SetScore(2, 43);
   \       0x84   0x212B             MOVS     R1,#+43
   \       0x86   0x2002             MOVS     R0,#+2
   \       0x88   0x....'....        BL       SetScore
    164              SetScore(3, 1);
   \       0x8C   0x2101             MOVS     R1,#+1
   \       0x8E   0x2003             MOVS     R0,#+3
   \       0x90   0x....'....        BL       SetScore
    165            }
    166            else
    167            {
    168              /* The task isn't properly initialized, so shut it down and don't run */
    169              UserApp1_StateMachine = UserApp1SM_Error;
    170            }
    171          
    172          } /* end UserApp1Initialize() */
   \       0x94   0xBD10             POP      {R4,PC}          ;; return
    173          
    174            
    175          /*----------------------------------------------------------------------------------------------------------------------
    176          Function UserApp1RunActiveState()
    177          
    178          Description:
    179          Selects and runs one iteration of the current state in the state machine.
    180          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    181          may take 1ms / n to execute.
    182          
    183          Requires:
    184            - State machine function pointer points at current state
    185          
    186          Promises:
    187            - Calls the function to pointed by the state machine function pointer
    188          */

   \                                 In section .text, align 2, keep-with-next
    189          void UserApp1RunActiveState(void)
    190          {
   \                     UserApp1RunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    191            UserApp1_StateMachine();
   \        0x2   0x....'....        LDR.W    R0,??DataTable8
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    192          
    193          } /* end UserApp1RunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    194          
    195          
    196          /*--------------------------------------------------------------------------------------------------------------------*/
    197          /* Private functions                                                                                                  */
    198          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    199          static GameboardErrorType drawDot(GameboardCoordinateType* coordinate_, DrawType drawType_)
    200          {
   \                     drawDot: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    201            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawDot_0
    202            {
    203              return BOUNDARY_ERROR_DOT_X;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE048             B.N      ??drawDot_1
    204            }
    205            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawDot_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawDot_2
    206            {
    207              return BOUNDARY_ERROR_DOT_Y;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE043             B.N      ??drawDot_1
    208            }
    209            
    210            u8 i, j;
    211            for(i = 0; i < GAMEBOARD_DOT_WIDTH; i++)
   \                     ??drawDot_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawDot_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xDA2A             BGE.N    ??drawDot_4
    212            {
    213              for(j = 0; j < GAMEBOARD_DOT_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawDot_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xDA22             BGE.N    ??drawDot_6
    214              {
    215                PixelAddressType pixel =
    216                {
    217                  .u16PixelRowAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET) + i,
    218                  .u16PixelColumnAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET) + j
    219                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1C89             ADDS     R1,R1,#+2
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1C89             ADDS     R1,R1,#+2
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    220                
    221                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawDot_7
    222                {
    223                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawDot_8
    224                }
    225                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawDot_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawDot_8
    226                {
    227                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    228                }
    229              }
   \                     ??drawDot_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawDot_5
    230            }
   \                     ??drawDot_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawDot_3
    231            
    232            PixelBlockType updateArea =
    233            {
    234              .u16RowStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET),
    235              .u16ColumnStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET),
    236              .u16RowSize = GAMEBOARD_DOT_WIDTH,
    237              .u16ColumnSize = GAMEBOARD_DOT_WIDTH
    238            };
   \                     ??drawDot_4: (+1)
   \       0x7A   0x....'....        LDR.W    R2,??DataTable8_7
   \       0x7E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x82   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0x00C0             LSLS     R0,R0,#+3
   \       0x8A   0x1C80             ADDS     R0,R0,#+2
   \       0x8C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x90   0x7860             LDRB     R0,[R4, #+1]
   \       0x92   0x00C0             LSLS     R0,R0,#+3
   \       0x94   0x1C80             ADDS     R0,R0,#+2
   \       0x96   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    239            
    240            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x....'....        BL       LcdUpdateScreenRefreshArea
    241            
    242            return GAMEBOARD_SUCCESS;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??drawDot_1: (+1)
   \       0xA2   0xBDFE             POP      {R1-R7,PC}       ;; return
    243          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000 0x0000      DC16 0, 0, 3, 3
   \               0x0003 0x000
   \              3            
    244          

   \                                 In section .text, align 2, keep-with-next
    245          static GameboardErrorType drawVerticalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    246          {
   \                     drawVerticalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    247            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawVerticalLine_0
    248            {
    249              return BOUNDARY_ERROR_VLINE_X;
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0xE048             B.N      ??drawVerticalLine_1
    250            }
    251            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE - 1)
   \                     ??drawVerticalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2807             CMP      R0,#+7
   \       0x14   0xDB01             BLT.N    ??drawVerticalLine_2
    252            {
    253              return BOUNDARY_ERROR_VLINE_Y;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xE043             B.N      ??drawVerticalLine_1
    254            }
    255            
    256            u8 i, j;
    257            for(i = 0; i < GAMEBOARD_LINE_LENGTH; i++)
   \                     ??drawVerticalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawVerticalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2805             CMP      R0,#+5
   \       0x22   0xDA2A             BGE.N    ??drawVerticalLine_4
    258            {
    259              for(j = 0; j < GAMEBOARD_LINE_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawVerticalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD122             BNE.N    ??drawVerticalLine_6
    260              {
    261                PixelAddressType pixel =
    262                {
    263                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    264                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    265                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1D49             ADDS     R1,R1,#+5
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1CC9             ADDS     R1,R1,#+3
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    266                
    267                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawVerticalLine_7
    268                {
    269                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawVerticalLine_8
    270                }
    271                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawVerticalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawVerticalLine_8
    272                {
    273                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    274                }
    275              }
   \                     ??drawVerticalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawVerticalLine_5
    276            }
   \                     ??drawVerticalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawVerticalLine_3
    277            
    278            PixelBlockType updateArea =
    279            {
    280              .u16RowStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    281              .u16ColumnStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    282              .u16RowSize = GAMEBOARD_LINE_LENGTH,
    283              .u16ColumnSize = GAMEBOARD_LINE_WIDTH
    284            };
   \                     ??drawVerticalLine_4: (+1)
   \       0x7A   0x....'....        LDR.W    R2,??DataTable8_8
   \       0x7E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x82   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0x00C0             LSLS     R0,R0,#+3
   \       0x8A   0x1D40             ADDS     R0,R0,#+5
   \       0x8C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x90   0x7860             LDRB     R0,[R4, #+1]
   \       0x92   0x00C0             LSLS     R0,R0,#+3
   \       0x94   0x1CC0             ADDS     R0,R0,#+3
   \       0x96   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    285            
    286            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x....'....        BL       LcdUpdateScreenRefreshArea
    287            
    288            return GAMEBOARD_SUCCESS;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??drawVerticalLine_1: (+1)
   \       0xA2   0xBDFE             POP      {R1-R7,PC}       ;; return
    289          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000 0x0000      DC16 0, 0, 5, 1
   \               0x0005 0x000
   \              1            
    290          

   \                                 In section .text, align 2, keep-with-next
    291          static GameboardErrorType drawHorizontalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    292          {
   \                     drawHorizontalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    293            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE - 1)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2807             CMP      R0,#+7
   \        0xA   0xDB01             BLT.N    ??drawHorizontalLine_0
    294            {
    295              return BOUNDARY_ERROR_HLINE_X;
   \        0xC   0x2005             MOVS     R0,#+5
   \        0xE   0xE047             B.N      ??drawHorizontalLine_1
    296            }
    297            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawHorizontalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawHorizontalLine_2
    298            {
    299              return BOUNDARY_ERROR_HLINE_Y;
   \       0x16   0x2006             MOVS     R0,#+6
   \       0x18   0xE042             B.N      ??drawHorizontalLine_1
    300            }
    301            
    302            u8 i, j;
    303            for(i = 0; i < GAMEBOARD_LINE_WIDTH; i++)
   \                     ??drawHorizontalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawHorizontalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD12A             BNE.N    ??drawHorizontalLine_4
    304            {
    305              for(j = 0; j < GAMEBOARD_LINE_LENGTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawHorizontalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2805             CMP      R0,#+5
   \       0x2E   0xDA22             BGE.N    ??drawHorizontalLine_6
    306              {
    307                PixelAddressType pixel =
    308                {
    309                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    310                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    311                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1CC9             ADDS     R1,R1,#+3
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1D49             ADDS     R1,R1,#+5
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    312                
    313                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawHorizontalLine_7
    314                {
    315                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawHorizontalLine_8
    316                }
    317                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawHorizontalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawHorizontalLine_8
    318                {
    319                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    320                }
    321              }
   \                     ??drawHorizontalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawHorizontalLine_5
    322            }
   \                     ??drawHorizontalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawHorizontalLine_3
    323            
    324            PixelBlockType updateArea =
    325            {
    326              .u16RowStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    327              .u16ColumnStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    328              .u16RowSize = GAMEBOARD_LINE_WIDTH,
    329              .u16ColumnSize = GAMEBOARD_LINE_LENGTH
    330            };
   \                     ??drawHorizontalLine_4: (+1)
   \       0x7A   0x....             LDR.N    R2,??DataTable8_9
   \       0x7C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x80   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x84   0x7820             LDRB     R0,[R4, #+0]
   \       0x86   0x00C0             LSLS     R0,R0,#+3
   \       0x88   0x1CC0             ADDS     R0,R0,#+3
   \       0x8A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x8E   0x7860             LDRB     R0,[R4, #+1]
   \       0x90   0x00C0             LSLS     R0,R0,#+3
   \       0x92   0x1D40             ADDS     R0,R0,#+5
   \       0x94   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    331            
    332            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x98   0xA801             ADD      R0,SP,#+4
   \       0x9A   0x....'....        BL       LcdUpdateScreenRefreshArea
    333            
    334            return GAMEBOARD_SUCCESS;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??drawHorizontalLine_1: (+1)
   \       0xA0   0xBDFE             POP      {R1-R7,PC}       ;; return
    335          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000 0x0000      DC16 0, 0, 1, 5
   \               0x0001 0x000
   \              5            
    336          

   \                                 In section .text, align 2, keep-with-next
    337          static GameboardErrorType drawEmptyGameboard(void)
    338          {
   \                     drawEmptyGameboard: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    339            u8 i, j;
    340            for(i = 0; i < GAMEBOARD_SIZE; i++)
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??drawEmptyGameboard_0: (+1)
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDA10             BGE.N    ??drawEmptyGameboard_1
    341            {
    342              for(j = 0; j < GAMEBOARD_SIZE; j++)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x0005             MOVS     R5,R0
   \                     ??drawEmptyGameboard_2: (+1)
   \       0x10   0x0028             MOVS     R0,R5
   \       0x12   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x14   0x2808             CMP      R0,#+8
   \       0x16   0xDA08             BGE.N    ??drawEmptyGameboard_3
    343              {
    344                GameboardCoordinateType coordinate =
    345                {
    346                  .u8RowCoordinate = i,
    347                  .u8ColumnCoordinate = j
    348                };
   \       0x18   0xF88D 0x4000      STRB     R4,[SP, #+0]
   \       0x1C   0xF88D 0x5001      STRB     R5,[SP, #+1]
    349                setDot(&coordinate);
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x....'....        BL       setDot
    350              }
   \       0x26   0x1C6D             ADDS     R5,R5,#+1
   \       0x28   0xE7F2             B.N      ??drawEmptyGameboard_2
    351            }
   \                     ??drawEmptyGameboard_3: (+1)
   \       0x2A   0x1C64             ADDS     R4,R4,#+1
   \       0x2C   0xE7EA             B.N      ??drawEmptyGameboard_0
    352            
    353            return GAMEBOARD_SUCCESS;
   \                     ??drawEmptyGameboard_1: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    354          }
    355          
    356          static GameboardErrorType testGameboardDrawingFunctions(void)
                                           ^
Warning[Pe177]: function "testGameboardDrawingFunctions" was declared but never
          referenced
    357          {
    358              static u8 i = 0;
    359              static u8 j = 0;
    360              static DrawingTestState state = SETTING_DOTS;
    361              GameboardErrorType err;
    362              GameboardCoordinateType coord;
    363              
    364              switch(state)
    365              {
    366                case SETTING_DOTS:
    367                  coord.u8RowCoordinate = i;
    368                  coord.u8ColumnCoordinate = j;
    369                  err = setDot(&coord);
    370                  if(err != GAMEBOARD_SUCCESS)
    371                  {
    372                    return err;
    373                  }
    374                  if(j < 7)
    375                  {
    376                    j++;
    377                  }
    378                  else if(i < 7)
    379                  {
    380                    i++;
    381                    j = 0;
    382                  }
    383                  else
    384                  {
    385                    i = 0;
    386                    j = 0;
    387                    state = SETTING_VLINES;
    388                  }
    389                  break;
    390                  
    391                case SETTING_VLINES:
    392                  coord.u8RowCoordinate = i;
    393                  coord.u8ColumnCoordinate = j;
    394                  err = setVerticalLine(&coord);
    395                  if(err != GAMEBOARD_SUCCESS)
    396                  {
    397                    return err;
    398                  }
    399                  if(j < 7)
    400                  {
    401                    j++;
    402                  }
    403                  else if(i < 6)
    404                  {
    405                    i++;
    406                    j = 0;
    407                  }
    408                  else
    409                  {
    410                    i = 0; 
    411                    j = 0; 
    412                    state = SETTING_HLINES;
    413                  }
    414                  break;
    415                  
    416                case SETTING_HLINES:
    417                  coord.u8RowCoordinate = i;
    418                  coord.u8ColumnCoordinate = j;
    419                  err = setHorizontalLine(&coord);
    420                  if(err != GAMEBOARD_SUCCESS)
    421                  {
    422                    return err;
    423                  }
    424                  if(j < 6)
    425                  {
    426                    j++;
    427                  }
    428                  else if( i < 7)
    429                  {
    430                    i++;
    431                    j = 0;
    432                  }
    433                  else
    434                  {
    435                    state = CLEARING_HLINES;
    436                  }
    437                  break;
    438                  
    439              case CLEARING_HLINES:
    440                coord.u8RowCoordinate = i;
    441                coord.u8ColumnCoordinate = j;
    442                err = clearHorizontalLine(&coord);
    443                if(err != GAMEBOARD_SUCCESS)
    444                {
    445                  return err;
    446                }
    447                if(j != 0)
    448                {
    449                  j--;
    450                }
    451                else if(i != 0)
    452                {
    453                  i--;
    454                  j = 6;
    455                }
    456                else
    457                {
    458                  i = 6;
    459                  j = 7;
    460                  state = CLEARING_VLINES;
    461                }
    462                break;
    463                
    464              case CLEARING_VLINES:
    465                coord.u8RowCoordinate = i;
    466                coord.u8ColumnCoordinate = j;
    467                err = clearVerticalLine(&coord);
    468                if(err != GAMEBOARD_SUCCESS)
    469                {
    470                  return err;
    471                }
    472                if(j != 0)
    473                {
    474                  j--;
    475                }
    476                else if(i != 0)
    477                {
    478                  i--;
    479                  j = 7;
    480                }
    481                else
    482                {
    483                  i = 7;
    484                  j = 7;
    485                  state = CLEARING_DOTS;
    486                }
    487                break;
    488                
    489              case CLEARING_DOTS:
    490                coord.u8RowCoordinate = i;
    491                coord.u8ColumnCoordinate = j;
    492                err = clearDot(&coord);
    493                if(err != GAMEBOARD_SUCCESS)
    494                {
    495                  return err;
    496                }
    497                if(j != 0)
    498                {
    499                  j--;
    500                }
    501                else if(i != 0)
    502                {
    503                  i--;
    504                  j = 7;
    505                }
    506                else
    507                {
    508                  state = DRAWING_COMPLETE;
    509                }
    510              }
    511          
    512              return GAMEBOARD_SUCCESS;
    513          }
    514          

   \                                 In section .text, align 2, keep-with-next
    515          static GameboardErrorType blinkCursor(void)
    516          {
   \                     blinkCursor: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    517            if(u32Timer % 250 == 0)
   \        0x2   0x20FA             MOVS     R0,#+250
   \        0x4   0x....             LDR.N    R1,??DataTable8_6
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x6809             LDR      R1,[R1, #+0]
   \        0xA   0xFBB1 0xF1F0      UDIV     R1,R1,R0
   \        0xE   0xFB00 0x2011      MLS      R0,R0,R1,R2
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD11F             BNE.N    ??blinkCursor_0
    518            {
    519              switch(cursor.cursorState)
   \       0x16   0x....             LDR.N    R4,??DataTable8_1
   \       0x18   0x78A0             LDRB     R0,[R4, #+2]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ.N    ??blinkCursor_1
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD00D             BEQ.N    ??blinkCursor_2
   \       0x22   0xE018             B.N      ??blinkCursor_0
    520              {
    521                case CURSOR_OFF:
    522                  err = setDot(&cursor.cursorLocation);
   \                     ??blinkCursor_1: (+1)
   \       0x24   0x....             LDR.N    R5,??DataTable8_10
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x....'....        BL       setDot
   \       0x2C   0x7028             STRB     R0,[R5, #+0]
    523                  if(err != GAMEBOARD_SUCCESS)
   \       0x2E   0x7828             LDRB     R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD001             BEQ.N    ??blinkCursor_3
    524                  {
    525                    return err;
   \       0x34   0x7828             LDRB     R0,[R5, #+0]
   \       0x36   0xE00F             B.N      ??blinkCursor_4
    526                  }
    527                  cursor.cursorState = CURSOR_ON;
   \                     ??blinkCursor_3: (+1)
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0x70A0             STRB     R0,[R4, #+2]
    528                  break;
   \       0x3C   0xE00B             B.N      ??blinkCursor_0
    529                  
    530                case CURSOR_ON:
    531                  err = clearDot(&cursor.cursorLocation);
   \                     ??blinkCursor_2: (+1)
   \       0x3E   0x....             LDR.N    R5,??DataTable8_10
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       clearDot
   \       0x46   0x7028             STRB     R0,[R5, #+0]
    532                  if(err != GAMEBOARD_SUCCESS)
   \       0x48   0x7828             LDRB     R0,[R5, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD001             BEQ.N    ??blinkCursor_5
    533                  {
    534                    return err;
   \       0x4E   0x7828             LDRB     R0,[R5, #+0]
   \       0x50   0xE002             B.N      ??blinkCursor_4
    535                  }
    536                  cursor.cursorState = CURSOR_OFF;
   \                     ??blinkCursor_5: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x70A0             STRB     R0,[R4, #+2]
    537                  break;
    538              }
    539            }
    540            
    541            return GAMEBOARD_SUCCESS;
   \                     ??blinkCursor_0: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??blinkCursor_4: (+1)
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    542          }
    543          

   \                                 In section .text, align 2, keep-with-next
    544          static GameboardErrorType moveCursor(void)
    545          {
   \                     moveCursor: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    546            u8 horizontalSliderPos = CaptouchCurrentHSlidePosition();
   \        0x4   0x....'....        BL       CaptouchCurrentHSlidePosition
   \        0x8   0x0004             MOVS     R4,R0
    547            u8 verticalSliderPos = CaptouchCurrentVSlidePosition();
   \        0xA   0x....'....        BL       CaptouchCurrentVSlidePosition
   \        0xE   0x0005             MOVS     R5,R0
    548            
    549            switch(horizontalMoveState)
   \       0x10   0x....             LDR.N    R6,??DataTable8_2
   \       0x12   0x7830             LDRB     R0,[R6, #+0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD002             BEQ.N    ??moveCursor_0
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD00B             BEQ.N    ??moveCursor_1
   \       0x1C   0xE04B             B.N      ??moveCursor_2
    550            {
    551              case MOVEMENT_NOT_STARTED:
    552                if(horizontalSliderPos >= CAPTOUCH_HORIZONTAL_LEFT_THRESHOLD &&
    553                   horizontalSliderPos < CAPTOUCH_HORIZONTAL_RIGHT_THRESHOLD)
   \                     ??moveCursor_0: (+1)
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x22   0x2840             CMP      R0,#+64
   \       0x24   0xDB05             BLT.N    ??moveCursor_3
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2A   0x28C0             CMP      R0,#+192
   \       0x2C   0xDA01             BGE.N    ??moveCursor_3
    554                {
    555                  horizontalMoveState = MOVEMENT_STARTED;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x7030             STRB     R0,[R6, #+0]
    556                }
    557                break;
   \                     ??moveCursor_3: (+1)
   \       0x32   0xE040             B.N      ??moveCursor_2
    558              case MOVEMENT_STARTED:
    559                if(horizontalSliderPos < CAPTOUCH_HORIZONTAL_LEFT_THRESHOLD)
   \                     ??moveCursor_1: (+1)
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x38   0x2840             CMP      R0,#+64
   \       0x3A   0xDA1C             BGE.N    ??moveCursor_4
    560                {
    561                  /* Check if the cursor is already at the left border of the screen. */
    562                  if(cursor.cursorLocation.u8ColumnCoordinate == 0)
   \       0x3C   0x....             LDR.N    R7,??DataTable8_1
   \       0x3E   0x7878             LDRB     R0,[R7, #+1]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0xD038             BEQ.N    ??moveCursor_2
    563                  {
    564                    break;
    565                  }
    566                  /* If the cursor is currently off, turn it on before moving it. */
    567                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_5: (+1)
   \       0x44   0x78B8             LDRB     R0,[R7, #+2]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xD10F             BNE.N    ??moveCursor_6
    568                  {
    569                    err = setDot(&cursor.cursorLocation);
   \       0x4A   0x....'....        LDR.W    R8,??DataTable8_10
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0x....'....        BL       setDot
   \       0x54   0xF888 0x0000      STRB     R0,[R8, #+0]
    570                    if(err != GAMEBOARD_SUCCESS)
   \       0x58   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD002             BEQ.N    ??moveCursor_7
    571                    {
    572                      return err;
   \       0x60   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x64   0xE07B             B.N      ??moveCursor_8
    573                    }
    574                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_7: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0x70B8             STRB     R0,[R7, #+2]
    575                  }
    576                  
    577                  /* Update the cursor location and move the cursor state machine. */
    578                  cursor.cursorLocation.u8ColumnCoordinate--;
   \                     ??moveCursor_6: (+1)
   \       0x6A   0x7878             LDRB     R0,[R7, #+1]
   \       0x6C   0x1E40             SUBS     R0,R0,#+1
   \       0x6E   0x7078             STRB     R0,[R7, #+1]
    579                  horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0x70   0x2000             MOVS     R0,#+0
   \       0x72   0x7030             STRB     R0,[R6, #+0]
   \       0x74   0xE01F             B.N      ??moveCursor_9
    580                }
    581                else if(horizontalSliderPos >= CAPTOUCH_HORIZONTAL_RIGHT_THRESHOLD)
   \                     ??moveCursor_4: (+1)
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x7A   0x28C0             CMP      R0,#+192
   \       0x7C   0xDB1B             BLT.N    ??moveCursor_9
    582                {
    583                  /* Check if the cursor is already at the right border of the screen. */
    584                  if(cursor.cursorLocation.u8ColumnCoordinate == GAMEBOARD_SIZE - 1)
   \       0x7E   0x....             LDR.N    R7,??DataTable8_1
   \       0x80   0x7878             LDRB     R0,[R7, #+1]
   \       0x82   0x2807             CMP      R0,#+7
   \       0x84   0xD017             BEQ.N    ??moveCursor_2
    585                  {
    586                    break;
    587                  }
    588                  
    589                  /* If the cursor is currently off, turn it on before moving it. */
    590                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_10: (+1)
   \       0x86   0x78B8             LDRB     R0,[R7, #+2]
   \       0x88   0x2800             CMP      R0,#+0
   \       0x8A   0xD10F             BNE.N    ??moveCursor_11
    591                  {
    592                    err = setDot(&cursor.cursorLocation);
   \       0x8C   0x....'....        LDR.W    R8,??DataTable8_10
   \       0x90   0x0038             MOVS     R0,R7
   \       0x92   0x....'....        BL       setDot
   \       0x96   0xF888 0x0000      STRB     R0,[R8, #+0]
    593                    if(err != GAMEBOARD_SUCCESS)
   \       0x9A   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD002             BEQ.N    ??moveCursor_12
    594                    {
    595                      return err;
   \       0xA2   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \       0xA6   0xE05A             B.N      ??moveCursor_8
    596                    }
    597                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_12: (+1)
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x70B8             STRB     R0,[R7, #+2]
    598                  }
    599                  
    600                  /* Update the cursor location and move the state machine. */
    601                  cursor.cursorLocation.u8ColumnCoordinate++;
   \                     ??moveCursor_11: (+1)
   \       0xAC   0x7878             LDRB     R0,[R7, #+1]
   \       0xAE   0x1C40             ADDS     R0,R0,#+1
   \       0xB0   0x7078             STRB     R0,[R7, #+1]
    602                  horizontalMoveState = MOVEMENT_NOT_STARTED;
   \       0xB2   0x2000             MOVS     R0,#+0
   \       0xB4   0x7030             STRB     R0,[R6, #+0]
    603                }
    604                break;
    605            }
    606            
    607            switch(verticalMoveState)
   \                     ??moveCursor_9: (+1)
   \                     ??moveCursor_2: (+1)
   \       0xB6   0x....             LDR.N    R6,??DataTable8_3
   \       0xB8   0x7830             LDRB     R0,[R6, #+0]
   \       0xBA   0x2800             CMP      R0,#+0
   \       0xBC   0xD002             BEQ.N    ??moveCursor_13
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD00B             BEQ.N    ??moveCursor_14
   \       0xC2   0xE04B             B.N      ??moveCursor_15
    608            {
    609              case MOVEMENT_NOT_STARTED:
    610                if(verticalSliderPos >= CAPTOUCH_VERTICAL_DOWN_THRESHOLD &&
    611                   verticalSliderPos < CAPTOUCH_VERTICAL_UP_THRESHOLD)
   \                     ??moveCursor_13: (+1)
   \       0xC4   0x0028             MOVS     R0,R5
   \       0xC6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xC8   0x2840             CMP      R0,#+64
   \       0xCA   0xDB05             BLT.N    ??moveCursor_16
   \       0xCC   0x0028             MOVS     R0,R5
   \       0xCE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xD0   0x28C0             CMP      R0,#+192
   \       0xD2   0xDA01             BGE.N    ??moveCursor_16
    612                {
    613                  verticalMoveState = MOVEMENT_STARTED;
   \       0xD4   0x2001             MOVS     R0,#+1
   \       0xD6   0x7030             STRB     R0,[R6, #+0]
    614                }
    615                break;
   \                     ??moveCursor_16: (+1)
   \       0xD8   0xE040             B.N      ??moveCursor_15
    616              case MOVEMENT_STARTED:
    617                if(verticalSliderPos < CAPTOUCH_VERTICAL_DOWN_THRESHOLD)
   \                     ??moveCursor_14: (+1)
   \       0xDA   0x0028             MOVS     R0,R5
   \       0xDC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xDE   0x2840             CMP      R0,#+64
   \       0xE0   0xDA1C             BGE.N    ??moveCursor_17
    618                {
    619                  /* Check if the cursor is already at the bottom border of the screen. */
    620                  if(cursor.cursorLocation.u8RowCoordinate == 0)
   \       0xE2   0x....             LDR.N    R7,??DataTable8_1
   \       0xE4   0x7838             LDRB     R0,[R7, #+0]
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD038             BEQ.N    ??moveCursor_15
    621                  {
    622                    break;
    623                  }
    624                  /* If the cursor is currently off, turn it on before moving it. */
    625                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_18: (+1)
   \       0xEA   0x78B8             LDRB     R0,[R7, #+2]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD10F             BNE.N    ??moveCursor_19
    626                  {
    627                    err = setDot(&cursor.cursorLocation);
   \       0xF0   0x....'....        LDR.W    R8,??DataTable8_10
   \       0xF4   0x0038             MOVS     R0,R7
   \       0xF6   0x....'....        BL       setDot
   \       0xFA   0xF888 0x0000      STRB     R0,[R8, #+0]
    628                    if(err != GAMEBOARD_SUCCESS)
   \       0xFE   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x102   0x2800             CMP      R0,#+0
   \      0x104   0xD002             BEQ.N    ??moveCursor_20
    629                    {
    630                      return err;
   \      0x106   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x10A   0xE028             B.N      ??moveCursor_8
    631                    }
    632                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_20: (+1)
   \      0x10C   0x2001             MOVS     R0,#+1
   \      0x10E   0x70B8             STRB     R0,[R7, #+2]
    633                  }
    634                  
    635                  /* Update the cursor location and move the cursor state machine. */
    636                  cursor.cursorLocation.u8RowCoordinate--;
   \                     ??moveCursor_19: (+1)
   \      0x110   0x7838             LDRB     R0,[R7, #+0]
   \      0x112   0x1E40             SUBS     R0,R0,#+1
   \      0x114   0x7038             STRB     R0,[R7, #+0]
    637                  verticalMoveState = MOVEMENT_NOT_STARTED;
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x7030             STRB     R0,[R6, #+0]
   \      0x11A   0xE01F             B.N      ??moveCursor_21
    638                }
    639                else if(verticalSliderPos >= CAPTOUCH_VERTICAL_UP_THRESHOLD)
   \                     ??moveCursor_17: (+1)
   \      0x11C   0x0028             MOVS     R0,R5
   \      0x11E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x120   0x28C0             CMP      R0,#+192
   \      0x122   0xDB1B             BLT.N    ??moveCursor_21
    640                {
    641                  /* Check if the cursor is already at the upper border of the screen. */
    642                  if(cursor.cursorLocation.u8RowCoordinate == GAMEBOARD_SIZE - 1)
   \      0x124   0x....             LDR.N    R7,??DataTable8_1
   \      0x126   0x7838             LDRB     R0,[R7, #+0]
   \      0x128   0x2807             CMP      R0,#+7
   \      0x12A   0xD017             BEQ.N    ??moveCursor_15
    643                  {
    644                    break;
    645                  }
    646                  
    647                  /* If the cursor is currently off, turn it on before moving it. */
    648                  if(cursor.cursorState == CURSOR_OFF)
   \                     ??moveCursor_22: (+1)
   \      0x12C   0x78B8             LDRB     R0,[R7, #+2]
   \      0x12E   0x2800             CMP      R0,#+0
   \      0x130   0xD10F             BNE.N    ??moveCursor_23
    649                  {
    650                    err = setDot(&cursor.cursorLocation);
   \      0x132   0x....'....        LDR.W    R8,??DataTable8_10
   \      0x136   0x0038             MOVS     R0,R7
   \      0x138   0x....'....        BL       setDot
   \      0x13C   0xF888 0x0000      STRB     R0,[R8, #+0]
    651                    if(err != GAMEBOARD_SUCCESS)
   \      0x140   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x144   0x2800             CMP      R0,#+0
   \      0x146   0xD002             BEQ.N    ??moveCursor_24
    652                    {
    653                      return err;
   \      0x148   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \      0x14C   0xE007             B.N      ??moveCursor_8
    654                    }
    655                    cursor.cursorState = CURSOR_ON;
   \                     ??moveCursor_24: (+1)
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0x70B8             STRB     R0,[R7, #+2]
    656                  }
    657                  
    658                  /* Update the cursor location and move the state machine. */
    659                  cursor.cursorLocation.u8RowCoordinate++;
   \                     ??moveCursor_23: (+1)
   \      0x152   0x7838             LDRB     R0,[R7, #+0]
   \      0x154   0x1C40             ADDS     R0,R0,#+1
   \      0x156   0x7038             STRB     R0,[R7, #+0]
    660                  verticalMoveState = MOVEMENT_NOT_STARTED;
   \      0x158   0x2000             MOVS     R0,#+0
   \      0x15A   0x7030             STRB     R0,[R6, #+0]
    661                }
    662                break;
    663            }
    664            
    665            return GAMEBOARD_SUCCESS;
   \                     ??moveCursor_21: (+1)
   \                     ??moveCursor_15: (+1)
   \      0x15C   0x2000             MOVS     R0,#+0
   \                     ??moveCursor_8: (+1)
   \      0x15E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    666          }
    667          /**********************************************************************************************************************
    668          State Machine Function Definitions
    669          **********************************************************************************************************************/
    670          
    671          /*-------------------------------------------------------------------------------------------------------------------*/
    672          /* Wait for ??? */

   \                                 In section .text, align 4, keep-with-next
    673          static void UserApp1SM_Idle(void)
    674          {
   \                     UserApp1SM_Idle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    675            switch(userPlayState)
   \        0x2   0x....             LDR.N    R0,??DataTable8_4
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD003             BEQ.N    ??UserApp1SM_Idle_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD00A             BEQ.N    ??UserApp1SM_Idle_1
   \        0xE   0xD308             BCC.N    ??UserApp1SM_Idle_2
   \       0x10   0xE008             B.N      ??UserApp1SM_Idle_3
    676            {
    677              /* Here the user has not selected any dots to start their turn. Functionality should allow the user to move around
    678               * the gameboard by blinking the cursor, and moving the cursor based on input from the captouch sensors. The next
    679               * state (SELECTED_FIRST_DOT) is achieved after the user has selected a dot with BUTTON1 */
    680              case SELECTED_NOTHING:
    681                err = blinkCursor();
   \                     ??UserApp1SM_Idle_0: (+1)
   \       0x12   0x....             LDR.N    R4,??DataTable8_10
   \       0x14   0x....'....        BL       blinkCursor
   \       0x18   0x7020             STRB     R0,[R4, #+0]
    682                if(err != GAMEBOARD_SUCCESS)
    683                {
    684                  //????
    685                }
    686                err = moveCursor();
   \       0x1A   0x....'....        BL       moveCursor
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
    687                if(err != GAMEBOARD_SUCCESS)
    688                {
    689                  //????
    690                }
    691                break;
   \       0x20   0xE000             B.N      ??UserApp1SM_Idle_3
    692              
    693              /* Here the user has selected one dot and must now select a second. Functionality should allow the user to select
    694               * between possible second dots by blinking a possible line that would connect two dots and switch between possible
    695               * line options by taking input from the captouch sensors. From here, the user can go back to the previous state
    696               * (SELECT_NOTHING) by pressing BUTTON0 or go forward to the next state (SELECTED_SECOND_DOT) by pressing BUTTON1
    697               * when they've reached their desired second dot option. */
    698              case SELECTED_FIRST_DOT:
    699                break;
   \                     ??UserApp1SM_Idle_2: (+1)
   \       0x22   0xE7FF             B.N      ??UserApp1SM_Idle_3
    700              
    701               /* Here the user has selected both dots and their turn is over. No more functionality must be provided to the user
    702                * until the user play state machine is started again. The players move on the gameboard should be updated in the
    703                * global gameboard variable */
    704              case SELECTED_SECOND_DOT:
    705                break;
    706            }
    707            
    708            /* Don't ever remove this! Other functions are depending on it!! */
    709            u32Timer++;
   \                     ??UserApp1SM_Idle_1: (+1)
   \                     ??UserApp1SM_Idle_3: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable8_6
   \       0x26   0x6801             LDR      R1,[R0, #+0]
   \       0x28   0x1C49             ADDS     R1,R1,#+1
   \       0x2A   0x6001             STR      R1,[R0, #+0]
    710            
    711          } /* end UserApp1SM_Idle() */
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     UserApp1_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x....'....        DC32     cursor

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x....'....        DC32     horizontalMoveState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x....'....        DC32     verticalMoveState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \        0x0   0x....'....        DC32     userPlayState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \        0x0   0x....'....        DC32     gameboard

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \        0x0   0x....'....        DC32     u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \        0x0   0x....'....        DC32     err
    712              
    713          
    714          /*-------------------------------------------------------------------------------------------------------------------*/
    715          /* Handle an error */
    716          static void UserApp1SM_Error(void)          
    717          {
    718            
    719          } /* end UserApp1SM_Error() */
    720          
    721          
    722          
    723          /*--------------------------------------------------------------------------------------------------------------------*/
    724          /* End of File                                                                                                        */
    725          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserApp1Initialize
         8   -> CapTouchOn
         8   -> LcdClearScreen
         8   -> SetNumberOfPlayers
         8   -> SetScore
         8   -> drawEmptyGameboard
         8   -> malloc
       8   UserApp1RunActiveState
         8   -- Indirect call
       8   UserApp1SM_Idle
         8   -> blinkCursor
         8   -> moveCursor
      16   blinkCursor
        16   -> clearDot
        16   -> setDot
       8   clearDot
         8   -> drawDot
       8   clearHorizontalLine
         8   -> drawHorizontalLine
       8   clearVerticalLine
         8   -> drawVerticalLine
      32   drawDot
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      16   drawEmptyGameboard
        16   -> setDot
      32   drawHorizontalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      32   drawVerticalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      24   moveCursor
        24   -> CaptouchCurrentHSlidePosition
        24   -> CaptouchCurrentVSlidePosition
        24   -> setDot
       8   setDot
         8   -> drawDot
       8   setHorizontalLine
         8   -> drawHorizontalLine
       8   setVerticalLine
         8   -> drawVerticalLine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       8  ?_0
       8  ?_1
       8  ?_2
       4  G_u32UserApp1Flags
     150  UserApp1Initialize
      12  UserApp1RunActiveState
      46  UserApp1SM_Idle
       4  UserApp1_StateMachine
      90  blinkCursor
      14  clearDot
      14  clearHorizontalLine
      14  clearVerticalLine
       4  cursor
     164  drawDot
      50  drawEmptyGameboard
     162  drawHorizontalLine
     164  drawVerticalLine
       1  err
       8  gameboard
       1  horizontalMoveState
     354  moveCursor
      14  setDot
      14  setHorizontalLine
      14  setVerticalLine
       4  u32Timer
       1  userPlayState
       1  verticalMoveState

 
    28 bytes in section .bss
    24 bytes in section .rodata
 1 320 bytes in section .text
 
 1 320 bytes of CODE  memory
    24 bytes of CONST memory
    28 bytes of DATA  memory

Errors: none
Warnings: 1
