###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         12/Jan/2019  16:13:21
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        Z:\Code\eie_iot_game_fw\firmware_common\application\user_app1.c
#    Command line =  
#        -f C:\Users\BUDWAN~1\AppData\Local\Temp\EW5534.tmp
#        (Z:\Code\eie_iot_game_fw\firmware_common\application\user_app1.c -D
#        MPGL2 -D MPG2 --preprocess=c
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List -lC
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List -o
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\ -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\bsp\ -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\drivers\ -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\application\
#        -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\libraries\captouch\
#        -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\
#        -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.2\arm\CMSIS\Core\Include\" -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\List\user_app1.lst
#    Object file  =  
#        Z:\Code\eie_iot_game_fw\firmware_dotmatrix\iar_7_20_1\Debug\Obj\user_app1.o
#
###############################################################################

Z:\Code\eie_iot_game_fw\firmware_common\application\user_app1.c
      1          /**********************************************************************************************************************
      2          File: user_app1.c                                                                
      3          
      4          ----------------------------------------------------------------------------------------------------------------------
      5          To start a new task using this user_app1 as a template:
      6           1. Copy both user_app1.c and user_app1.h to the Application directory
      7           2. Rename the files yournewtaskname.c and yournewtaskname.h
      8           3. Add yournewtaskname.c and yournewtaskname.h to the Application Include and Source groups in the IAR project
      9           4. Use ctrl-h (make sure "Match Case" is checked) to find and replace all instances of "user_app1" with "yournewtaskname"
     10           5. Use ctrl-h to find and replace all instances of "UserApp1" with "YourNewTaskName"
     11           6. Use ctrl-h to find and replace all instances of "USER_APP1" with "YOUR_NEW_TASK_NAME"
     12           7. Add a call to YourNewTaskNameInitialize() in the init section of main
     13           8. Add a call to YourNewTaskNameRunActiveState() in the Super Loop section of main
     14           9. Update yournewtaskname.h per the instructions at the top of yournewtaskname.h
     15          10. Delete this text (between the dashed lines) and update the Description below to describe your task
     16          ----------------------------------------------------------------------------------------------------------------------
     17          
     18          Description:
     19          This is a user_app1.c file template 
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          Public functions:
     25          
     26          
     27          Protected System functions:
     28          void UserApp1Initialize(void)
     29          Runs required initialzation for the task.  Should only be called once in main init section.
     30          
     31          void UserApp1RunActiveState(void)
     32          Runs current task state.  Should only be called once in main loop.
     33          
     34          
     35          **********************************************************************************************************************/
     36          
     37          #include "configuration.h"
     38          
     39          /***********************************************************************************************************************
     40          Global variable definitions with scope across entire project.
     41          All Global variable names shall start with "G_UserApp1"
     42          ***********************************************************************************************************************/
     43          /* New variables */

   \                                 In section .bss, align 4
     44          volatile u32 G_u32UserApp1Flags;                       /* Global state flags */
   \                     G_u32UserApp1Flags:
   \        0x0                      DS8 4
     45          
     46          
     47          /*--------------------------------------------------------------------------------------------------------------------*/
     48          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     49          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     50          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     51          
     52          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     53          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     54          
     55          
     56          /***********************************************************************************************************************
     57          Global variable definitions with scope limited to this local application.
     58          Variable names shall start with "UserApp1_" and be declared as static.
     59          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     60          static fnCode_type UserApp1_StateMachine;            /* The state machine function pointer */
   \                     UserApp1_StateMachine:
   \        0x0                      DS8 4
     61          //static u32 UserApp1_u32Timeout;                      /* Timeout counter used across states */
     62          
     63          /**********************************************************************************************************************
     64          Function Definitions
     65          **********************************************************************************************************************/
     66          
     67          /*--------------------------------------------------------------------------------------------------------------------*/
     68          /* Public functions                                                                                                   */
     69          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
     70          GameboardErrorType setDot(GameboardCoordinateType* coordinate_)
     71          {
   \                     setDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     72            return drawDot(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     73          }
     74          

   \                                 In section .text, align 2, keep-with-next
     75          GameboardErrorType clearDot(GameboardCoordinateType* coordinate_)
     76          {
   \                     clearDot: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     77            return drawDot(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawDot
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     78          }
     79          

   \                                 In section .text, align 2, keep-with-next
     80          GameboardErrorType setVerticalLine(GameboardCoordinateType* coordinate_)
     81          {
   \                     setVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     82            return drawVerticalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     83          }
     84          

   \                                 In section .text, align 2, keep-with-next
     85          GameboardErrorType clearVerticalLine(GameboardCoordinateType* coordinate_)
     86          {
   \                     clearVerticalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     87            return drawVerticalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawVerticalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     88          }
     89          

   \                                 In section .text, align 2, keep-with-next
     90          GameboardErrorType setHorizontalLine(GameboardCoordinateType* coordinate_)
     91          {
   \                     setHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     92            return drawHorizontalLine(coordinate_, DRAW_SET);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     93          }
     94          

   \                                 In section .text, align 2, keep-with-next
     95          GameboardErrorType clearHorizontalLine(GameboardCoordinateType* coordinate_)
     96          {
   \                     clearHorizontalLine: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
     97            return drawHorizontalLine(coordinate_, DRAW_CLEAR);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x....'....        BL       drawHorizontalLine
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
     98          }
     99          /*--------------------------------------------------------------------------------------------------------------------*/
    100          /* Protected functions                                                                                                */
    101          /*--------------------------------------------------------------------------------------------------------------------*/
    102          
    103          /*--------------------------------------------------------------------------------------------------------------------
    104          Function: UserApp1Initialize
    105          
    106          Description:
    107          Initializes the State Machine and its variables.
    108          
    109          Requires:
    110            -
    111          
    112          Promises:
    113            - 
    114          */

   \                                 In section .text, align 2, keep-with-next
    115          void UserApp1Initialize(void)
    116          {
   \                     UserApp1Initialize: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    117           
    118            /* If good initialization, set state to Idle */
    119            if( 1 )
    120            {
    121              UserApp1_StateMachine = UserApp1SM_Idle;
   \        0x2   0x....'....        ADR.W    R0,UserApp1SM_Idle
   \        0x6   0x....'....        LDR.W    R1,??DataTable7
   \        0xA   0x6008             STR      R0,[R1, #+0]
    122              
    123              LcdClearScreen();
   \        0xC   0x....'....        BL       LcdClearScreen
    124              /*drawEmptyGameboard();
    125              
    126              u8 i , j;
    127              for(i = 0; i < GAMEBOARD_SIZE; i++)
    128              {
    129                for(j = 0; j < GAMEBOARD_SIZE - 1; j++)
    130                {
    131                  GameboardCoordinateType lineLocation =
    132                  {
    133                    .u8RowCoordinate = i,
    134                    .u8ColumnCoordinate = j
    135                  };
    136                  drawHorizontalLine(&lineLocation);
    137                }
    138              }*/
    139            }
    140            else
    141            {
    142              /* The task isn't properly initialized, so shut it down and don't run */
    143              UserApp1_StateMachine = UserApp1SM_Error;
    144            }
    145          
    146          } /* end UserApp1Initialize() */
   \       0x10   0xBD01             POP      {R0,PC}          ;; return
    147          
    148            
    149          /*----------------------------------------------------------------------------------------------------------------------
    150          Function UserApp1RunActiveState()
    151          
    152          Description:
    153          Selects and runs one iteration of the current state in the state machine.
    154          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    155          may take 1ms / n to execute.
    156          
    157          Requires:
    158            - State machine function pointer points at current state
    159          
    160          Promises:
    161            - Calls the function to pointed by the state machine function pointer
    162          */

   \                                 In section .text, align 2, keep-with-next
    163          void UserApp1RunActiveState(void)
    164          {
   \                     UserApp1RunActiveState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    165            UserApp1_StateMachine();
   \        0x2   0x....'....        LDR.W    R0,??DataTable7
   \        0x6   0x6800             LDR      R0,[R0, #+0]
   \        0x8   0x4780             BLX      R0
    166          
    167          } /* end UserApp1RunActiveState */
   \        0xA   0xBD01             POP      {R0,PC}          ;; return
    168          
    169          
    170          /*--------------------------------------------------------------------------------------------------------------------*/
    171          /* Private functions                                                                                                  */
    172          /*--------------------------------------------------------------------------------------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
    173          static GameboardErrorType drawDot(GameboardCoordinateType* coordinate_, DrawType drawType_)
    174          {
   \                     drawDot: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    175            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawDot_0
    176            {
    177              return BOUNDARY_ERROR_DOT_X;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE048             B.N      ??drawDot_1
    178            }
    179            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawDot_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawDot_2
    180            {
    181              return BOUNDARY_ERROR_DOT_Y;
   \       0x16   0x2002             MOVS     R0,#+2
   \       0x18   0xE043             B.N      ??drawDot_1
    182            }
    183            
    184            u8 i, j;
    185            for(i = 0; i < GAMEBOARD_DOT_WIDTH; i++)
   \                     ??drawDot_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawDot_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2803             CMP      R0,#+3
   \       0x22   0xDA2A             BGE.N    ??drawDot_4
    186            {
    187              for(j = 0; j < GAMEBOARD_DOT_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawDot_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2803             CMP      R0,#+3
   \       0x2E   0xDA22             BGE.N    ??drawDot_6
    188              {
    189                PixelAddressType pixel =
    190                {
    191                  .u16PixelRowAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET) + i,
    192                  .u16PixelColumnAddress = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET) + j
    193                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1C89             ADDS     R1,R1,#+2
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1C89             ADDS     R1,R1,#+2
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    194                
    195                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawDot_7
    196                {
    197                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawDot_8
    198                }
    199                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawDot_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawDot_8
    200                {
    201                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    202                }
    203              }
   \                     ??drawDot_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawDot_5
    204            }
   \                     ??drawDot_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawDot_3
    205            
    206            PixelBlockType updateArea =
    207            {
    208              .u16RowStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_DOT_OFFSET),
    209              .u16ColumnStart = GAMEBOARD_BORDER_DOT_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_DOT_OFFSET),
    210              .u16RowSize = GAMEBOARD_DOT_WIDTH,
    211              .u16ColumnSize = GAMEBOARD_DOT_WIDTH
    212            };
   \                     ??drawDot_4: (+1)
   \       0x7A   0x....'....        LDR.W    R2,??DataTable7_1
   \       0x7E   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x82   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x86   0x7820             LDRB     R0,[R4, #+0]
   \       0x88   0x00C0             LSLS     R0,R0,#+3
   \       0x8A   0x1C80             ADDS     R0,R0,#+2
   \       0x8C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x90   0x7860             LDRB     R0,[R4, #+1]
   \       0x92   0x00C0             LSLS     R0,R0,#+3
   \       0x94   0x1C80             ADDS     R0,R0,#+2
   \       0x96   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    213            
    214            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x9A   0xA801             ADD      R0,SP,#+4
   \       0x9C   0x....'....        BL       LcdUpdateScreenRefreshArea
    215            
    216            return GAMEBOARD_SUCCESS;
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??drawDot_1: (+1)
   \       0xA2   0xBDFE             POP      {R1-R7,PC}       ;; return
    217          }

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0000 0x0000      DC16 0, 0, 3, 3
   \               0x0003 0x000
   \              3            
    218          

   \                                 In section .text, align 2, keep-with-next
    219          static GameboardErrorType drawVerticalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    220          {
   \                     drawVerticalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    221            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2808             CMP      R0,#+8
   \        0xA   0xDB01             BLT.N    ??drawVerticalLine_0
    222            {
    223              return BOUNDARY_ERROR_VLINE_X;
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0xE047             B.N      ??drawVerticalLine_1
    224            }
    225            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE - 1)
   \                     ??drawVerticalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2807             CMP      R0,#+7
   \       0x14   0xDB01             BLT.N    ??drawVerticalLine_2
    226            {
    227              return BOUNDARY_ERROR_VLINE_Y;
   \       0x16   0x2004             MOVS     R0,#+4
   \       0x18   0xE042             B.N      ??drawVerticalLine_1
    228            }
    229            
    230            u8 i, j;
    231            for(i = 0; i < GAMEBOARD_LINE_LENGTH; i++)
   \                     ??drawVerticalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawVerticalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2805             CMP      R0,#+5
   \       0x22   0xDA2A             BGE.N    ??drawVerticalLine_4
    232            {
    233              for(j = 0; j < GAMEBOARD_LINE_WIDTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawVerticalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD122             BNE.N    ??drawVerticalLine_6
    234              {
    235                PixelAddressType pixel =
    236                {
    237                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    238                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    239                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1D49             ADDS     R1,R1,#+5
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1CC9             ADDS     R1,R1,#+3
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    240                
    241                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawVerticalLine_7
    242                {
    243                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawVerticalLine_8
    244                }
    245                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawVerticalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawVerticalLine_8
    246                {
    247                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    248                }
    249              }
   \                     ??drawVerticalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawVerticalLine_5
    250            }
   \                     ??drawVerticalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawVerticalLine_3
    251            
    252            PixelBlockType updateArea =
    253            {
    254              .u16RowStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    255              .u16ColumnStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    256              .u16RowSize = GAMEBOARD_LINE_LENGTH,
    257              .u16ColumnSize = GAMEBOARD_LINE_WIDTH
    258            };
   \                     ??drawVerticalLine_4: (+1)
   \       0x7A   0x....             LDR.N    R2,??DataTable7_2
   \       0x7C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x80   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x84   0x7820             LDRB     R0,[R4, #+0]
   \       0x86   0x00C0             LSLS     R0,R0,#+3
   \       0x88   0x1D40             ADDS     R0,R0,#+5
   \       0x8A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x8E   0x7860             LDRB     R0,[R4, #+1]
   \       0x90   0x00C0             LSLS     R0,R0,#+3
   \       0x92   0x1CC0             ADDS     R0,R0,#+3
   \       0x94   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    259            
    260            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x98   0xA801             ADD      R0,SP,#+4
   \       0x9A   0x....'....        BL       LcdUpdateScreenRefreshArea
    261            
    262            return GAMEBOARD_SUCCESS;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??drawVerticalLine_1: (+1)
   \       0xA0   0xBDFE             POP      {R1-R7,PC}       ;; return
    263          }

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0000 0x0000      DC16 0, 0, 5, 1
   \               0x0005 0x000
   \              1            
    264          

   \                                 In section .text, align 2, keep-with-next
    265          static GameboardErrorType drawHorizontalLine(GameboardCoordinateType* coordinate_, DrawType drawType_)
    266          {
   \                     drawHorizontalLine: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    267            if(coordinate_->u8ColumnCoordinate >= GAMEBOARD_SIZE - 1)
   \        0x6   0x7860             LDRB     R0,[R4, #+1]
   \        0x8   0x2807             CMP      R0,#+7
   \        0xA   0xDB01             BLT.N    ??drawHorizontalLine_0
    268            {
    269              return BOUNDARY_ERROR_HLINE_X;
   \        0xC   0x2005             MOVS     R0,#+5
   \        0xE   0xE047             B.N      ??drawHorizontalLine_1
    270            }
    271            else if(coordinate_->u8RowCoordinate >= GAMEBOARD_SIZE)
   \                     ??drawHorizontalLine_0: (+1)
   \       0x10   0x7820             LDRB     R0,[R4, #+0]
   \       0x12   0x2808             CMP      R0,#+8
   \       0x14   0xDB01             BLT.N    ??drawHorizontalLine_2
    272            {
    273              return BOUNDARY_ERROR_HLINE_Y;
   \       0x16   0x2006             MOVS     R0,#+6
   \       0x18   0xE042             B.N      ??drawHorizontalLine_1
    274            }
    275            
    276            u8 i, j;
    277            for(i = 0; i < GAMEBOARD_LINE_WIDTH; i++)
   \                     ??drawHorizontalLine_2: (+1)
   \       0x1A   0x2700             MOVS     R7,#+0
   \                     ??drawHorizontalLine_3: (+1)
   \       0x1C   0x0038             MOVS     R0,R7
   \       0x1E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD12A             BNE.N    ??drawHorizontalLine_4
    278            {
    279              for(j = 0; j < GAMEBOARD_LINE_LENGTH; j++)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x0006             MOVS     R6,R0
   \                     ??drawHorizontalLine_5: (+1)
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x2C   0x2805             CMP      R0,#+5
   \       0x2E   0xDA22             BGE.N    ??drawHorizontalLine_6
    280              {
    281                PixelAddressType pixel =
    282                {
    283                  .u16PixelRowAddress = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET) + i,
    284                  .u16PixelColumnAddress = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET) + j
    285                };
   \       0x30   0x7820             LDRB     R0,[R4, #+0]
   \       0x32   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x34   0x0039             MOVS     R1,R7
   \       0x36   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x38   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x3C   0x1CC9             ADDS     R1,R1,#+3
   \       0x3E   0xF8AD 0x1000      STRH     R1,[SP, #+0]
   \       0x42   0x7860             LDRB     R0,[R4, #+1]
   \       0x44   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \       0x4A   0xEB11 0x01C0      ADDS     R1,R1,R0, LSL #+3
   \       0x4E   0x1D49             ADDS     R1,R1,#+5
   \       0x50   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    286                
    287                if(drawType_ == DRAW_SET)
   \       0x54   0x0028             MOVS     R0,R5
   \       0x56   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD103             BNE.N    ??drawHorizontalLine_7
    288                {
    289                  LcdSetPixel(&pixel);
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x....'....        BL       LcdSetPixel
   \       0x62   0xE006             B.N      ??drawHorizontalLine_8
    290                }
    291                else if(drawType_ == DRAW_CLEAR)
   \                     ??drawHorizontalLine_7: (+1)
   \       0x64   0x0028             MOVS     R0,R5
   \       0x66   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x68   0x2801             CMP      R0,#+1
   \       0x6A   0xD102             BNE.N    ??drawHorizontalLine_8
    292                {
    293                  LcdClearPixel(&pixel);
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x....'....        BL       LcdClearPixel
    294                }
    295              }
   \                     ??drawHorizontalLine_8: (+1)
   \       0x72   0x1C76             ADDS     R6,R6,#+1
   \       0x74   0xE7D8             B.N      ??drawHorizontalLine_5
    296            }
   \                     ??drawHorizontalLine_6: (+1)
   \       0x76   0x1C7F             ADDS     R7,R7,#+1
   \       0x78   0xE7D0             B.N      ??drawHorizontalLine_3
    297            
    298            PixelBlockType updateArea =
    299            {
    300              .u16RowStart = GAMEBOARD_BORDER_LINE_WIDTH_OFFSET + (coordinate_->u8RowCoordinate * GAMEBOARD_LINE_OFFSET),
    301              .u16ColumnStart = GAMEBOARD_BORDER_LINE_LENGTH_OFFSET + (coordinate_->u8ColumnCoordinate * GAMEBOARD_LINE_OFFSET),
    302              .u16RowSize = GAMEBOARD_LINE_WIDTH,
    303              .u16ColumnSize = GAMEBOARD_LINE_LENGTH
    304            };
   \                     ??drawHorizontalLine_4: (+1)
   \       0x7A   0x....             LDR.N    R2,??DataTable7_3
   \       0x7C   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \       0x80   0xE9CD 0x0101      STRD     R0,R1,[SP, #+4]
   \       0x84   0x7820             LDRB     R0,[R4, #+0]
   \       0x86   0x00C0             LSLS     R0,R0,#+3
   \       0x88   0x1CC0             ADDS     R0,R0,#+3
   \       0x8A   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0x8E   0x7860             LDRB     R0,[R4, #+1]
   \       0x90   0x00C0             LSLS     R0,R0,#+3
   \       0x92   0x1D40             ADDS     R0,R0,#+5
   \       0x94   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    305            
    306            LcdUpdateScreenRefreshArea(&updateArea);
   \       0x98   0xA801             ADD      R0,SP,#+4
   \       0x9A   0x....'....        BL       LcdUpdateScreenRefreshArea
    307            
    308            return GAMEBOARD_SUCCESS;
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??drawHorizontalLine_1: (+1)
   \       0xA0   0xBDFE             POP      {R1-R7,PC}       ;; return
    309          }

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0000 0x0000      DC16 0, 0, 1, 5
   \               0x0001 0x000
   \              5            
    310          
    311          static GameboardErrorType drawEmptyGameboard(void)
                                           ^
Warning[Pe177]: function "drawEmptyGameboard" was declared but never referenced
    312          {
    313            u8 i, j;
    314            for(i = 0; i < GAMEBOARD_SIZE; i++)
    315            {
    316              for(j = 0; j < GAMEBOARD_SIZE; j++)
    317              {
    318                GameboardCoordinateType coordinate =
    319                {
    320                  .u8RowCoordinate = i,
    321                  .u8ColumnCoordinate = j
    322                };
    323                setDot(&coordinate);
    324              }
    325            }
    326            
    327            return GAMEBOARD_SUCCESS;
    328          }
    329          

   \                                 In section .text, align 2, keep-with-next
    330          static GameboardErrorType testGameboardDrawingFunctions(void)
    331          {
   \                     testGameboardDrawingFunctions: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    332              static u8 i = 0;
    333              static u8 j = 0;
    334              static DrawingTestState state = SETTING_DOTS;
    335              GameboardErrorType err;
    336              GameboardCoordinateType coord;
    337              
    338              switch(state)
   \        0x2   0x....             LDR.N    R5,??DataTable7_4
   \        0x4   0x7828             LDRB     R0,[R5, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD00A             BEQ.N    ??testGameboardDrawingFunctions_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD05C             BEQ.N    ??testGameboardDrawingFunctions_1
   \        0xE   0xD331             BCC.N    ??testGameboardDrawingFunctions_2
   \       0x10   0x2804             CMP      R0,#+4
   \       0x12   0xF000 0x80A9      BEQ.W    ??testGameboardDrawingFunctions_3
   \       0x16   0xD37D             BCC.N    ??testGameboardDrawingFunctions_4
   \       0x18   0x2805             CMP      R0,#+5
   \       0x1A   0xF000 0x80CF      BEQ.W    ??testGameboardDrawingFunctions_5
   \       0x1E   0xE0F2             B.N      ??testGameboardDrawingFunctions_6
    339              {
    340                case SETTING_DOTS:
    341                  coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_0: (+1)
   \       0x20   0x....             LDR.N    R6,??DataTable7_5
   \       0x22   0x7830             LDRB     R0,[R6, #+0]
   \       0x24   0xF88D 0x0000      STRB     R0,[SP, #+0]
    342                  coord.u8ColumnCoordinate = j;
   \       0x28   0x....             LDR.N    R7,??DataTable7_6
   \       0x2A   0x7838             LDRB     R0,[R7, #+0]
   \       0x2C   0xF88D 0x0001      STRB     R0,[SP, #+1]
    343                  err = setDot(&coord);
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x....'....        BL       setDot
   \       0x36   0x0004             MOVS     R4,R0
    344                  if(err != GAMEBOARD_SUCCESS)
   \       0x38   0x0020             MOVS     R0,R4
   \       0x3A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD002             BEQ.N    ??testGameboardDrawingFunctions_7
    345                  {
    346                    return err;
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x44   0xE0E0             B.N      ??testGameboardDrawingFunctions_8
    347                  }
    348                  if(j < 7)
   \                     ??testGameboardDrawingFunctions_7: (+1)
   \       0x46   0x7838             LDRB     R0,[R7, #+0]
   \       0x48   0x2807             CMP      R0,#+7
   \       0x4A   0xDA03             BGE.N    ??testGameboardDrawingFunctions_9
    349                  {
    350                    j++;
   \       0x4C   0x7838             LDRB     R0,[R7, #+0]
   \       0x4E   0x1C40             ADDS     R0,R0,#+1
   \       0x50   0x7038             STRB     R0,[R7, #+0]
   \       0x52   0xE00E             B.N      ??testGameboardDrawingFunctions_10
    351                  }
    352                  else if(i < 7)
   \                     ??testGameboardDrawingFunctions_9: (+1)
   \       0x54   0x7830             LDRB     R0,[R6, #+0]
   \       0x56   0x2807             CMP      R0,#+7
   \       0x58   0xDA05             BGE.N    ??testGameboardDrawingFunctions_11
    353                  {
    354                    i++;
   \       0x5A   0x7830             LDRB     R0,[R6, #+0]
   \       0x5C   0x1C40             ADDS     R0,R0,#+1
   \       0x5E   0x7030             STRB     R0,[R6, #+0]
    355                    j = 0;
   \       0x60   0x2000             MOVS     R0,#+0
   \       0x62   0x7038             STRB     R0,[R7, #+0]
   \       0x64   0xE005             B.N      ??testGameboardDrawingFunctions_10
    356                  }
    357                  else
    358                  {
    359                    i = 0;
   \                     ??testGameboardDrawingFunctions_11: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x7030             STRB     R0,[R6, #+0]
    360                    j = 0;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x7038             STRB     R0,[R7, #+0]
    361                    state = SETTING_VLINES;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0x7028             STRB     R0,[R5, #+0]
    362                  }
    363                  break;
   \                     ??testGameboardDrawingFunctions_10: (+1)
   \       0x72   0xE0C8             B.N      ??testGameboardDrawingFunctions_6
    364                  
    365                case SETTING_VLINES:
    366                  coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_2: (+1)
   \       0x74   0x....             LDR.N    R6,??DataTable7_5
   \       0x76   0x7830             LDRB     R0,[R6, #+0]
   \       0x78   0xF88D 0x0000      STRB     R0,[SP, #+0]
    367                  coord.u8ColumnCoordinate = j;
   \       0x7C   0x....             LDR.N    R7,??DataTable7_6
   \       0x7E   0x7838             LDRB     R0,[R7, #+0]
   \       0x80   0xF88D 0x0001      STRB     R0,[SP, #+1]
    368                  err = setVerticalLine(&coord);
   \       0x84   0x4668             MOV      R0,SP
   \       0x86   0x....'....        BL       setVerticalLine
   \       0x8A   0x0004             MOVS     R4,R0
    369                  if(err != GAMEBOARD_SUCCESS)
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x90   0x2800             CMP      R0,#+0
   \       0x92   0xD002             BEQ.N    ??testGameboardDrawingFunctions_12
    370                  {
    371                    return err;
   \       0x94   0x0020             MOVS     R0,R4
   \       0x96   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0x98   0xE0B6             B.N      ??testGameboardDrawingFunctions_8
    372                  }
    373                  if(j < 7)
   \                     ??testGameboardDrawingFunctions_12: (+1)
   \       0x9A   0x7838             LDRB     R0,[R7, #+0]
   \       0x9C   0x2807             CMP      R0,#+7
   \       0x9E   0xDA03             BGE.N    ??testGameboardDrawingFunctions_13
    374                  {
    375                    j++;
   \       0xA0   0x7838             LDRB     R0,[R7, #+0]
   \       0xA2   0x1C40             ADDS     R0,R0,#+1
   \       0xA4   0x7038             STRB     R0,[R7, #+0]
   \       0xA6   0xE00E             B.N      ??testGameboardDrawingFunctions_14
    376                  }
    377                  else if(i < 6)
   \                     ??testGameboardDrawingFunctions_13: (+1)
   \       0xA8   0x7830             LDRB     R0,[R6, #+0]
   \       0xAA   0x2806             CMP      R0,#+6
   \       0xAC   0xDA05             BGE.N    ??testGameboardDrawingFunctions_15
    378                  {
    379                    i++;
   \       0xAE   0x7830             LDRB     R0,[R6, #+0]
   \       0xB0   0x1C40             ADDS     R0,R0,#+1
   \       0xB2   0x7030             STRB     R0,[R6, #+0]
    380                    j = 0;
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x7038             STRB     R0,[R7, #+0]
   \       0xB8   0xE005             B.N      ??testGameboardDrawingFunctions_14
    381                  }
    382                  else
    383                  {
    384                    i = 0; 
   \                     ??testGameboardDrawingFunctions_15: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x7030             STRB     R0,[R6, #+0]
    385                    j = 0; 
   \       0xBE   0x2000             MOVS     R0,#+0
   \       0xC0   0x7038             STRB     R0,[R7, #+0]
    386                    state = SETTING_HLINES;
   \       0xC2   0x2002             MOVS     R0,#+2
   \       0xC4   0x7028             STRB     R0,[R5, #+0]
    387                  }
    388                  break;
   \                     ??testGameboardDrawingFunctions_14: (+1)
   \       0xC6   0xE09E             B.N      ??testGameboardDrawingFunctions_6
    389                  
    390                case SETTING_HLINES:
    391                  coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_1: (+1)
   \       0xC8   0x....             LDR.N    R6,??DataTable7_5
   \       0xCA   0x7830             LDRB     R0,[R6, #+0]
   \       0xCC   0xF88D 0x0000      STRB     R0,[SP, #+0]
    392                  coord.u8ColumnCoordinate = j;
   \       0xD0   0x....             LDR.N    R7,??DataTable7_6
   \       0xD2   0x7838             LDRB     R0,[R7, #+0]
   \       0xD4   0xF88D 0x0001      STRB     R0,[SP, #+1]
    393                  err = setHorizontalLine(&coord);
   \       0xD8   0x4668             MOV      R0,SP
   \       0xDA   0x....'....        BL       setHorizontalLine
   \       0xDE   0x0004             MOVS     R4,R0
    394                  if(err != GAMEBOARD_SUCCESS)
   \       0xE0   0x0020             MOVS     R0,R4
   \       0xE2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD002             BEQ.N    ??testGameboardDrawingFunctions_16
    395                  {
    396                    return err;
   \       0xE8   0x0020             MOVS     R0,R4
   \       0xEA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \       0xEC   0xE08C             B.N      ??testGameboardDrawingFunctions_8
    397                  }
    398                  if(j < 6)
   \                     ??testGameboardDrawingFunctions_16: (+1)
   \       0xEE   0x7838             LDRB     R0,[R7, #+0]
   \       0xF0   0x2806             CMP      R0,#+6
   \       0xF2   0xDA03             BGE.N    ??testGameboardDrawingFunctions_17
    399                  {
    400                    j++;
   \       0xF4   0x7838             LDRB     R0,[R7, #+0]
   \       0xF6   0x1C40             ADDS     R0,R0,#+1
   \       0xF8   0x7038             STRB     R0,[R7, #+0]
   \       0xFA   0xE00A             B.N      ??testGameboardDrawingFunctions_18
    401                  }
    402                  else if( i < 7)
   \                     ??testGameboardDrawingFunctions_17: (+1)
   \       0xFC   0x7830             LDRB     R0,[R6, #+0]
   \       0xFE   0x2807             CMP      R0,#+7
   \      0x100   0xDA05             BGE.N    ??testGameboardDrawingFunctions_19
    403                  {
    404                    i++;
   \      0x102   0x7830             LDRB     R0,[R6, #+0]
   \      0x104   0x1C40             ADDS     R0,R0,#+1
   \      0x106   0x7030             STRB     R0,[R6, #+0]
    405                    j = 0;
   \      0x108   0x2000             MOVS     R0,#+0
   \      0x10A   0x7038             STRB     R0,[R7, #+0]
   \      0x10C   0xE001             B.N      ??testGameboardDrawingFunctions_18
    406                  }
    407                  else
    408                  {
    409                    state = CLEARING_HLINES;
   \                     ??testGameboardDrawingFunctions_19: (+1)
   \      0x10E   0x2003             MOVS     R0,#+3
   \      0x110   0x7028             STRB     R0,[R5, #+0]
    410                  }
    411                  break;
   \                     ??testGameboardDrawingFunctions_18: (+1)
   \      0x112   0xE078             B.N      ??testGameboardDrawingFunctions_6
    412                  
    413              case CLEARING_HLINES:
    414                coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_4: (+1)
   \      0x114   0x....             LDR.N    R6,??DataTable7_5
   \      0x116   0x7830             LDRB     R0,[R6, #+0]
   \      0x118   0xF88D 0x0000      STRB     R0,[SP, #+0]
    415                coord.u8ColumnCoordinate = j;
   \      0x11C   0x....             LDR.N    R7,??DataTable7_6
   \      0x11E   0x7838             LDRB     R0,[R7, #+0]
   \      0x120   0xF88D 0x0001      STRB     R0,[SP, #+1]
    416                err = clearHorizontalLine(&coord);
   \      0x124   0x4668             MOV      R0,SP
   \      0x126   0x....'....        BL       clearHorizontalLine
   \      0x12A   0x0004             MOVS     R4,R0
    417                if(err != GAMEBOARD_SUCCESS)
   \      0x12C   0x0020             MOVS     R0,R4
   \      0x12E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x130   0x2800             CMP      R0,#+0
   \      0x132   0xD002             BEQ.N    ??testGameboardDrawingFunctions_20
    418                {
    419                  return err;
   \      0x134   0x0020             MOVS     R0,R4
   \      0x136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x138   0xE066             B.N      ??testGameboardDrawingFunctions_8
    420                }
    421                if(j != 0)
   \                     ??testGameboardDrawingFunctions_20: (+1)
   \      0x13A   0x7838             LDRB     R0,[R7, #+0]
   \      0x13C   0x2800             CMP      R0,#+0
   \      0x13E   0xD003             BEQ.N    ??testGameboardDrawingFunctions_21
    422                {
    423                  j--;
   \      0x140   0x7838             LDRB     R0,[R7, #+0]
   \      0x142   0x1E40             SUBS     R0,R0,#+1
   \      0x144   0x7038             STRB     R0,[R7, #+0]
   \      0x146   0xE00E             B.N      ??testGameboardDrawingFunctions_22
    424                }
    425                else if(i != 0)
   \                     ??testGameboardDrawingFunctions_21: (+1)
   \      0x148   0x7830             LDRB     R0,[R6, #+0]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD005             BEQ.N    ??testGameboardDrawingFunctions_23
    426                {
    427                  i--;
   \      0x14E   0x7830             LDRB     R0,[R6, #+0]
   \      0x150   0x1E40             SUBS     R0,R0,#+1
   \      0x152   0x7030             STRB     R0,[R6, #+0]
    428                  j = 6;
   \      0x154   0x2006             MOVS     R0,#+6
   \      0x156   0x7038             STRB     R0,[R7, #+0]
   \      0x158   0xE005             B.N      ??testGameboardDrawingFunctions_22
    429                }
    430                else
    431                {
    432                  i = 6;
   \                     ??testGameboardDrawingFunctions_23: (+1)
   \      0x15A   0x2006             MOVS     R0,#+6
   \      0x15C   0x7030             STRB     R0,[R6, #+0]
    433                  j = 7;
   \      0x15E   0x2007             MOVS     R0,#+7
   \      0x160   0x7038             STRB     R0,[R7, #+0]
    434                  state = CLEARING_VLINES;
   \      0x162   0x2004             MOVS     R0,#+4
   \      0x164   0x7028             STRB     R0,[R5, #+0]
    435                }
    436                break;
   \                     ??testGameboardDrawingFunctions_22: (+1)
   \      0x166   0xE04E             B.N      ??testGameboardDrawingFunctions_6
    437                
    438              case CLEARING_VLINES:
    439                coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_3: (+1)
   \      0x168   0x....             LDR.N    R6,??DataTable7_5
   \      0x16A   0x7830             LDRB     R0,[R6, #+0]
   \      0x16C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    440                coord.u8ColumnCoordinate = j;
   \      0x170   0x....             LDR.N    R7,??DataTable7_6
   \      0x172   0x7838             LDRB     R0,[R7, #+0]
   \      0x174   0xF88D 0x0001      STRB     R0,[SP, #+1]
    441                err = clearVerticalLine(&coord);
   \      0x178   0x4668             MOV      R0,SP
   \      0x17A   0x....'....        BL       clearVerticalLine
   \      0x17E   0x0004             MOVS     R4,R0
    442                if(err != GAMEBOARD_SUCCESS)
   \      0x180   0x0020             MOVS     R0,R4
   \      0x182   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x184   0x2800             CMP      R0,#+0
   \      0x186   0xD002             BEQ.N    ??testGameboardDrawingFunctions_24
    443                {
    444                  return err;
   \      0x188   0x0020             MOVS     R0,R4
   \      0x18A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x18C   0xE03C             B.N      ??testGameboardDrawingFunctions_8
    445                }
    446                if(j != 0)
   \                     ??testGameboardDrawingFunctions_24: (+1)
   \      0x18E   0x7838             LDRB     R0,[R7, #+0]
   \      0x190   0x2800             CMP      R0,#+0
   \      0x192   0xD003             BEQ.N    ??testGameboardDrawingFunctions_25
    447                {
    448                  j--;
   \      0x194   0x7838             LDRB     R0,[R7, #+0]
   \      0x196   0x1E40             SUBS     R0,R0,#+1
   \      0x198   0x7038             STRB     R0,[R7, #+0]
   \      0x19A   0xE00E             B.N      ??testGameboardDrawingFunctions_26
    449                }
    450                else if(i != 0)
   \                     ??testGameboardDrawingFunctions_25: (+1)
   \      0x19C   0x7830             LDRB     R0,[R6, #+0]
   \      0x19E   0x2800             CMP      R0,#+0
   \      0x1A0   0xD005             BEQ.N    ??testGameboardDrawingFunctions_27
    451                {
    452                  i--;
   \      0x1A2   0x7830             LDRB     R0,[R6, #+0]
   \      0x1A4   0x1E40             SUBS     R0,R0,#+1
   \      0x1A6   0x7030             STRB     R0,[R6, #+0]
    453                  j = 7;
   \      0x1A8   0x2007             MOVS     R0,#+7
   \      0x1AA   0x7038             STRB     R0,[R7, #+0]
   \      0x1AC   0xE005             B.N      ??testGameboardDrawingFunctions_26
    454                }
    455                else
    456                {
    457                  i = 7;
   \                     ??testGameboardDrawingFunctions_27: (+1)
   \      0x1AE   0x2007             MOVS     R0,#+7
   \      0x1B0   0x7030             STRB     R0,[R6, #+0]
    458                  j = 7;
   \      0x1B2   0x2007             MOVS     R0,#+7
   \      0x1B4   0x7038             STRB     R0,[R7, #+0]
    459                  state = CLEARING_DOTS;
   \      0x1B6   0x2005             MOVS     R0,#+5
   \      0x1B8   0x7028             STRB     R0,[R5, #+0]
    460                }
    461                break;
   \                     ??testGameboardDrawingFunctions_26: (+1)
   \      0x1BA   0xE024             B.N      ??testGameboardDrawingFunctions_6
    462                
    463              case CLEARING_DOTS:
    464                coord.u8RowCoordinate = i;
   \                     ??testGameboardDrawingFunctions_5: (+1)
   \      0x1BC   0x....             LDR.N    R6,??DataTable7_5
   \      0x1BE   0x7830             LDRB     R0,[R6, #+0]
   \      0x1C0   0xF88D 0x0000      STRB     R0,[SP, #+0]
    465                coord.u8ColumnCoordinate = j;
   \      0x1C4   0x....             LDR.N    R7,??DataTable7_6
   \      0x1C6   0x7838             LDRB     R0,[R7, #+0]
   \      0x1C8   0xF88D 0x0001      STRB     R0,[SP, #+1]
    466                err = clearDot(&coord);
   \      0x1CC   0x4668             MOV      R0,SP
   \      0x1CE   0x....'....        BL       clearDot
   \      0x1D2   0x0004             MOVS     R4,R0
    467                if(err != GAMEBOARD_SUCCESS)
   \      0x1D4   0x0020             MOVS     R0,R4
   \      0x1D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD002             BEQ.N    ??testGameboardDrawingFunctions_28
    468                {
    469                  return err;
   \      0x1DC   0x0020             MOVS     R0,R4
   \      0x1DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \      0x1E0   0xE012             B.N      ??testGameboardDrawingFunctions_8
    470                }
    471                if(j != 0)
   \                     ??testGameboardDrawingFunctions_28: (+1)
   \      0x1E2   0x7838             LDRB     R0,[R7, #+0]
   \      0x1E4   0x2800             CMP      R0,#+0
   \      0x1E6   0xD003             BEQ.N    ??testGameboardDrawingFunctions_29
    472                {
    473                  j--;
   \      0x1E8   0x7838             LDRB     R0,[R7, #+0]
   \      0x1EA   0x1E40             SUBS     R0,R0,#+1
   \      0x1EC   0x7038             STRB     R0,[R7, #+0]
   \      0x1EE   0xE00A             B.N      ??testGameboardDrawingFunctions_30
    474                }
    475                else if(i != 0)
   \                     ??testGameboardDrawingFunctions_29: (+1)
   \      0x1F0   0x7830             LDRB     R0,[R6, #+0]
   \      0x1F2   0x2800             CMP      R0,#+0
   \      0x1F4   0xD005             BEQ.N    ??testGameboardDrawingFunctions_31
    476                {
    477                  i--;
   \      0x1F6   0x7830             LDRB     R0,[R6, #+0]
   \      0x1F8   0x1E40             SUBS     R0,R0,#+1
   \      0x1FA   0x7030             STRB     R0,[R6, #+0]
    478                  j = 7;
   \      0x1FC   0x2007             MOVS     R0,#+7
   \      0x1FE   0x7038             STRB     R0,[R7, #+0]
   \      0x200   0xE001             B.N      ??testGameboardDrawingFunctions_30
    479                }
    480                else
    481                {
    482                  state = DRAWING_COMPLETE;
   \                     ??testGameboardDrawingFunctions_31: (+1)
   \      0x202   0x2006             MOVS     R0,#+6
   \      0x204   0x7028             STRB     R0,[R5, #+0]
    483                }
    484              }
    485          
    486              return GAMEBOARD_SUCCESS;
   \                     ??testGameboardDrawingFunctions_30: (+1)
   \                     ??testGameboardDrawingFunctions_6: (+1)
   \      0x206   0x2000             MOVS     R0,#+0
   \                     ??testGameboardDrawingFunctions_8: (+1)
   \      0x208   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    487          }

   \                                 In section .bss, align 1
   \                     `testGameboardDrawingFunctions::i`:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     `testGameboardDrawingFunctions::j`:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
   \                     `testGameboardDrawingFunctions::state`:
   \        0x0                      DS8 1
    488          
    489          /**********************************************************************************************************************
    490          State Machine Function Definitions
    491          **********************************************************************************************************************/
    492          
    493          /*-------------------------------------------------------------------------------------------------------------------*/
    494          /* Wait for ??? */

   \                                 In section .text, align 4, keep-with-next
    495          static void UserApp1SM_Idle(void)
    496          {
   \                     UserApp1SM_Idle: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    497              static uint32_t timer = 0;
    498              
    499              if(timer % 100 == 0)
   \        0x2   0x2064             MOVS     R0,#+100
   \        0x4   0x....             LDR.N    R4,??DataTable7_7
   \        0x6   0x6821             LDR      R1,[R4, #+0]
   \        0x8   0x6822             LDR      R2,[R4, #+0]
   \        0xA   0xFBB2 0xF2F0      UDIV     R2,R2,R0
   \        0xE   0xFB00 0x1012      MLS      R0,R0,R2,R1
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD101             BNE.N    ??UserApp1SM_Idle_0
    500              {
    501                testGameboardDrawingFunctions();
   \       0x16   0x....'....        BL       testGameboardDrawingFunctions
    502              }
    503              timer++;
   \                     ??UserApp1SM_Idle_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x1C40             ADDS     R0,R0,#+1
   \       0x1E   0x6020             STR      R0,[R4, #+0]
    504          } /* end UserApp1SM_Idle() */
   \       0x20   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 4
   \                     `UserApp1SM_Idle::timer`:
   \        0x0                      DS8 4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0x....'....        DC32     UserApp1_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \        0x0   0x....'....        DC32     `testGameboardDrawingFunctions::state`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \        0x0   0x....'....        DC32     `testGameboardDrawingFunctions::i`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \        0x0   0x....'....        DC32     `testGameboardDrawingFunctions::j`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \        0x0   0x....'....        DC32     `UserApp1SM_Idle::timer`
    505              
    506          
    507          /*-------------------------------------------------------------------------------------------------------------------*/
    508          /* Handle an error */
    509          static void UserApp1SM_Error(void)          
    510          {
    511            
    512          } /* end UserApp1SM_Error() */
    513          
    514          
    515          
    516          /*--------------------------------------------------------------------------------------------------------------------*/
    517          /* End of File                                                                                                        */
    518          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   UserApp1Initialize
         8   -> LcdClearScreen
       8   UserApp1RunActiveState
         8   -- Indirect call
       8   UserApp1SM_Idle
         8   -> testGameboardDrawingFunctions
       8   clearDot
         8   -> drawDot
       8   clearHorizontalLine
         8   -> drawHorizontalLine
       8   clearVerticalLine
         8   -> drawVerticalLine
      32   drawDot
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      32   drawHorizontalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
      32   drawVerticalLine
        32   -> LcdClearPixel
        32   -> LcdSetPixel
        32   -> LcdUpdateScreenRefreshArea
       8   setDot
         8   -> drawDot
       8   setHorizontalLine
         8   -> drawHorizontalLine
       8   setVerticalLine
         8   -> drawVerticalLine
      24   testGameboardDrawingFunctions
        24   -> clearDot
        24   -> clearHorizontalLine
        24   -> clearVerticalLine
        24   -> setDot
        24   -> setHorizontalLine
        24   -> setVerticalLine


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       8  ?_0
       8  ?_1
       8  ?_2
       4  G_u32UserApp1Flags
      18  UserApp1Initialize
      12  UserApp1RunActiveState
      34  UserApp1SM_Idle
       4  UserApp1_StateMachine
      14  clearDot
      14  clearHorizontalLine
      14  clearVerticalLine
     164  drawDot
     162  drawHorizontalLine
     162  drawVerticalLine
       1  i
       1  j
      14  setDot
      14  setHorizontalLine
      14  setVerticalLine
       1  state
     522  testGameboardDrawingFunctions
       4  timer

 
    15 bytes in section .bss
    24 bytes in section .rodata
 1 190 bytes in section .text
 
 1 190 bytes of CODE  memory
    24 bytes of CONST memory
    15 bytes of DATA  memory

Errors: none
Warnings: 1
